# CompileScripts.cmake - Compile Ruby scripts to mruby bytecode and generate C header

function(compile_ruby_scripts TARGET_NAME SCRIPT_DIR OUTPUT_HEADER)
    # Find all .rb files in the scripts directory
    file(GLOB_RECURSE RUBY_SCRIPTS "${SCRIPT_DIR}/*.rb")

    if(NOT RUBY_SCRIPTS)
        message(WARNING "No Ruby scripts found in ${SCRIPT_DIR}")
        return()
    endif()

    # Determine mrbc compiler path based on platform
    if(PLATFORM_WEB)
        # For Emscripten builds, use host mrbc (must be built separately)
        if(DEFINED ENV{MRBC_PATH})
            set(MRBC_COMPILER $ENV{MRBC_PATH})
        else()
            find_program(MRBC_COMPILER mrbc
                PATHS
                    "${CMAKE_SOURCE_DIR}/deps/mruby/bin"
                    "C:/msys64/mingw64/bin"
                    "/usr/local/bin"
                    "/usr/bin"
            )
        endif()
    else()
        # For native builds, use system mrbc or deps
        find_program(MRBC_COMPILER mrbc
            PATHS
                "${CMAKE_SOURCE_DIR}/deps/mruby/bin"
                "C:/msys64/mingw64/bin"
                "/usr/local/bin"
                "/usr/bin"
        )
    endif()

    if(NOT MRBC_COMPILER)
        message(FATAL_ERROR "mrbc compiler not found. Please install mruby or set MRBC_PATH environment variable.")
    endif()

    message(STATUS "Using mrbc compiler: ${MRBC_COMPILER}")

    # Create output directory for intermediate .c files
    set(BYTECODE_DIR "${CMAKE_BINARY_DIR}/generated/bytecode")
    file(MAKE_DIRECTORY "${BYTECODE_DIR}")

    # List to hold all generated C files
    set(BYTECODE_C_FILES "")

    # Compile each Ruby script to bytecode C file, then wrap in C++
    foreach(RUBY_FILE ${RUBY_SCRIPTS})
        # Get relative path from script directory
        file(RELATIVE_PATH REL_PATH "${SCRIPT_DIR}" "${RUBY_FILE}")

        # Create symbol name from path (replace / and . with _)
        string(REPLACE "/" "_" SYMBOL_NAME "${REL_PATH}")
        string(REPLACE "\\" "_" SYMBOL_NAME "${SYMBOL_NAME}")
        string(REPLACE "." "_" SYMBOL_NAME "${SYMBOL_NAME}")

        # Output files
        set(C_FILE "${BYTECODE_DIR}/${SYMBOL_NAME}_raw.c")
        set(CPP_FILE "${BYTECODE_DIR}/${SYMBOL_NAME}.cpp")

        # Add custom command to compile Ruby to C bytecode
        add_custom_command(
            OUTPUT "${C_FILE}"
            COMMAND "${MRBC_COMPILER}" -B ${SYMBOL_NAME} -o ${C_FILE} "${RUBY_FILE}"
            DEPENDS "${RUBY_FILE}"
            COMMENT "Compiling Ruby bytecode: ${REL_PATH}"
            VERBATIM
        )

        # Create a C++ file that just includes the C file
        # This is simpler and more portable than setting source properties
        add_custom_command(
            OUTPUT "${CPP_FILE}"
            COMMAND ${CMAKE_COMMAND} -E echo "// Wrapper for ${REL_PATH}" > ${CPP_FILE}
            COMMAND ${CMAKE_COMMAND} -E echo "#include \"${SYMBOL_NAME}_raw.c\"" >> ${CPP_FILE}
            DEPENDS "${C_FILE}"
            VERBATIM
        )

        list(APPEND BYTECODE_C_FILES "${CPP_FILE}")
    endforeach()

    # Generate header file that declares all bytecode arrays
    set(HEADER_CONTENT "// Auto-generated by CMake - DO NOT EDIT\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}// Compiled mruby bytecode from scripts directory\n\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}#ifndef GMR_COMPILED_SCRIPTS_HPP\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}#define GMR_COMPILED_SCRIPTS_HPP\n\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}#include <cstddef>\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}#include <cstdint>\n\n")

    # Declare external bytecode arrays (generated by mrbc in global scope)
    set(HEADER_CONTENT "${HEADER_CONTENT}extern \"C\" {\n\n")
    foreach(RUBY_FILE ${RUBY_SCRIPTS})
        file(RELATIVE_PATH REL_PATH "${SCRIPT_DIR}" "${RUBY_FILE}")
        string(REPLACE "/" "_" SYMBOL_NAME "${REL_PATH}")
        string(REPLACE "\\" "_" SYMBOL_NAME "${SYMBOL_NAME}")
        string(REPLACE "." "_" SYMBOL_NAME "${SYMBOL_NAME}")

        set(HEADER_CONTENT "${HEADER_CONTENT}// ${REL_PATH}\n")
        set(HEADER_CONTENT "${HEADER_CONTENT}extern const uint8_t ${SYMBOL_NAME}[];\n\n")
    endforeach()
    set(HEADER_CONTENT "${HEADER_CONTENT}} // extern \"C\"\n\n")

    # Now create the namespace for our registry
    set(HEADER_CONTENT "${HEADER_CONTENT}namespace gmr {\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}namespace compiled_scripts {\n\n")

    # Create script registry structure
    set(HEADER_CONTENT "${HEADER_CONTENT}struct CompiledScript {\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}    const char* path;\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}    const uint8_t* bytecode;\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}};\n\n")

    # Count scripts
    list(LENGTH RUBY_SCRIPTS SCRIPT_COUNT)

    set(HEADER_CONTENT "${HEADER_CONTENT}// Total number of compiled scripts\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}constexpr size_t SCRIPT_COUNT = ${SCRIPT_COUNT};\n\n")

    set(HEADER_CONTENT "${HEADER_CONTENT}// Array of all compiled scripts\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}extern const CompiledScript SCRIPTS[SCRIPT_COUNT];\n\n")

    set(HEADER_CONTENT "${HEADER_CONTENT}} // namespace compiled_scripts\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}} // namespace gmr\n\n")
    set(HEADER_CONTENT "${HEADER_CONTENT}#endif // GMR_COMPILED_SCRIPTS_HPP\n")

    # Write header file
    file(WRITE "${OUTPUT_HEADER}" "${HEADER_CONTENT}")

    # Generate implementation file that defines the SCRIPTS array
    set(IMPL_FILE "${BYTECODE_DIR}/compiled_scripts_registry.cpp")
    set(IMPL_CONTENT "#include \"${OUTPUT_HEADER}\"\n\n")
    set(IMPL_CONTENT "${IMPL_CONTENT}namespace gmr {\n")
    set(IMPL_CONTENT "${IMPL_CONTENT}namespace compiled_scripts {\n\n")
    set(IMPL_CONTENT "${IMPL_CONTENT}const CompiledScript SCRIPTS[SCRIPT_COUNT] = {\n")

    foreach(RUBY_FILE ${RUBY_SCRIPTS})
        file(RELATIVE_PATH REL_PATH "${SCRIPT_DIR}" "${RUBY_FILE}")
        string(REPLACE "/" "_" SYMBOL_NAME "${REL_PATH}")
        string(REPLACE "\\" "_" SYMBOL_NAME "${SYMBOL_NAME}")
        string(REPLACE "." "_" SYMBOL_NAME "${SYMBOL_NAME}")

        # Normalize path separators for the registry
        string(REPLACE "\\" "/" NORMALIZED_PATH "${REL_PATH}")

        set(IMPL_CONTENT "${IMPL_CONTENT}    { \"${NORMALIZED_PATH}\", ${SYMBOL_NAME} },\n")
    endforeach()

    set(IMPL_CONTENT "${IMPL_CONTENT}};\n\n")
    set(IMPL_CONTENT "${IMPL_CONTENT}} // namespace compiled_scripts\n")
    set(IMPL_CONTENT "${IMPL_CONTENT}} // namespace gmr\n")

    file(WRITE "${IMPL_FILE}" "${IMPL_CONTENT}")

    # Add all bytecode C++ files and registry to the target
    list(APPEND BYTECODE_C_FILES "${IMPL_FILE}")
    target_sources(${TARGET_NAME} PRIVATE ${BYTECODE_C_FILES})

    message(STATUS "Configured ${SCRIPT_COUNT} Ruby scripts for bytecode compilation")

endfunction()
