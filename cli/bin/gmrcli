#!/usr/bin/env ruby
# frozen_string_literal: true

require "thor"
require_relative "../lib/gmrcli"

module Gmrcli
  # Main CLI application
  class CLI < Thor
    def self.exit_on_failure?
      true
    end

    # Override Thor's error handling for prettier output
    def self.handle_no_command_error(command, has_namespace = $thor_runner)
      UI.error "Unknown command: #{command}"
      UI.info "Run 'gmrcli help' for available commands"
      exit 1
    end

    class_option :verbose, type: :boolean, default: false, aliases: "-v",
                           desc: "Show detailed output"
    class_option :output, type: :string, default: "json", aliases: "-o",
                          desc: "Output format: json (default), text"
    class_option :protocol_version, type: :string, default: nil,
                                    desc: "Request specific protocol version (e.g., v1)"

    # Machine-first: JSON mode is enabled by default unless -o text is passed
    def initialize(*args)
      super

      # Validate protocol version if specified
      if options[:protocol_version]
        begin
          Protocol.negotiate(options[:protocol_version])
        rescue UnsupportedProtocolError => e
          # Emit error in JSON format (can't use human mode for protocol errors)
          error_envelope = {
            protocol: Protocol::VERSION,
            status: "error",
            command: nil,
            error: {
              code: "PROTOCOL.UNSUPPORTED",
              message: e.message,
              details: "Requested: #{e.requested}, Supported: #{e.supported.join(', ')}"
            }
          }
          puts error_envelope.to_json
          exit 2
        end
      end

      # Parse output format
      output_format = (options[:output] || "json").downcase

      # Validate output format
      unless %w[json text].include?(output_format)
        # For invalid format, emit error in JSON (safest default)
        error_envelope = {
          protocol: Protocol::VERSION,
          status: "error",
          command: nil,
          error: {
            code: "CLI.INVALID_OUTPUT_FORMAT",
            message: "Invalid output format: #{output_format}",
            details: "Valid formats: json, text"
          }
        }
        puts error_envelope.to_json
        exit 1
      end

      # Machine-first: Enable JSON by default, disable only if -o text is passed
      # Environment variable GMRCLI_OUTPUT=text also enables text mode (escape hatch)
      # Exception: 'dev' command defaults to text mode for interactive use
      text_mode = output_format == "text" || ENV["GMRCLI_OUTPUT"] == "text"

      # Dev command defaults to text unless user explicitly requests JSON
      # Check if user passed -o json, --output json, --output=json, or -ojson
      argv_str = ARGV.join(" ")
      explicit_json = argv_str.include?("-o json") ||
                      argv_str.include?("--output json") ||
                      argv_str.include?("--output=json") ||
                      ARGV.any? { |arg| arg == "-ojson" }
      if ARGV.first == "dev" && !explicit_json && ENV["GMRCLI_OUTPUT"] != "json"
        text_mode = true
      end

      JsonEmitter.enable! unless text_mode
    end

    # === Setup Command ===

    desc "setup", "Set up the GMR development environment"
    long_desc <<~DESC
      Installs all dependencies needed for GMR development:
      - System packages (gcc, cmake, ninja, mruby)
      - raylib (built from source)
      - Emscripten SDK (for web builds)
      - mruby for web (cross-compiled)

      Use --native-only for faster setup if you don't need web builds.
    DESC
    option :native_only, type: :boolean, default: false, aliases: "-n",
                         desc: "Skip web/Emscripten setup (faster)"
    option :skip_web, type: :boolean, default: false,
                      desc: "Same as --native-only"
    option :web_only, type: :boolean, default: false, aliases: "-w",
                      desc: "Only setup web/Emscripten (skip native)"
    option :skip_native, type: :boolean, default: false,
                         desc: "Same as --web-only"
    option :skip_pacman, type: :boolean, default: false,
                         desc: "Skip pacman package installation"
    option :clean, type: :boolean, default: false,
                   desc: "Clean everything and start fresh"
    option :fix_ssl, type: :boolean, default: false,
                     desc: "Fix SSL certificate issues"
    def setup
      ErrorHandler.wrap(command: "setup") do
        Commands::Setup.new(options.to_h.transform_keys(&:to_sym)).run
      end
    end

    # === Build Command ===

    desc "build [TARGET]", "Build the game"
    long_desc <<~DESC
      Build GMR for the specified target:
        debug    - Native debug build (default)
        release  - Native release build (optimized, no console)
        web      - Web/Emscripten build
        clean    - Remove all build artifacts
        all      - Build all targets
    DESC
    option :rebuild, type: :boolean, default: false, aliases: "-r",
                     desc: "Clean before building"
    def build(target = "debug")
      ErrorHandler.wrap(command: "build") do
        builder = Commands::Build.new(options.to_h.transform_keys(&:to_sym))

        case target.downcase
        when "debug"   then builder.debug
        when "release" then builder.release
        when "web"     then builder.web
        when "clean"   then builder.clean
        when "all"     then builder.all
        else
          raise Error.new(
            "Unknown build target: #{target}",
            code: "BUILD.INVALID_TARGET",
            suggestions: ["Available: debug, release, web, clean, all"]
          )
        end
      end
    end

    # === Start Command ===

    desc "start [TARGET]", "Run the game"
    long_desc <<~DESC
      Run GMR with the current project's scripts.

      By default, runs the native executable. Use 'web' to start a local web server.

      Targets:
        (default) - Run the native executable
        web       - Start a local web server for the web build

      The command looks for game/scripts/main.rb in the current directory.
      The GMR executable is found automatically from the project's release/ folder.
    DESC
    option :project, type: :string, aliases: "-p",
                     desc: "Path to project directory"
    option :port, type: :numeric, default: 8080,
                  desc: "Port for web server"
    option :topmost, type: :boolean, default: false,
                     desc: "Keep game window on top of other windows"
    def start(target = "")
      ErrorHandler.wrap(command: "run") do
        runner = Commands::Run.new(options.to_h.transform_keys(&:to_sym))

        case target.downcase
        when "", "native", "debug", "release" then runner.native
        when "web" then runner.web
        else
          raise Error.new(
            "Unknown run target: #{target}",
            code: "RUN.INVALID_TARGET",
            suggestions: ["Available: web (or omit for native)"]
          )
        end
      end
    end

    # === Run Command (alias for start) ===
    # Note: "run" is a Thor reserved word, so we use map to create the alias
    map "run" => :start

    # === New Command ===

    desc "new NAME", "Create a new GMR game project"
    long_desc <<~DESC
      Scaffolds a new GMR project with the following structure:
        NAME/
          game/
            scripts/
              main.rb       - Main game script
            assets/
              sprites/
              sounds/
              fonts/
              music/
          gmr.json        - Project configuration
          .gitignore

      Templates:
        basic  - Starter template with movement example (default)
        empty  - Minimal template with empty callbacks
    DESC
    option :template, type: :string, default: "basic", aliases: "-t",
                      desc: "Template: basic, empty"
    def new(name)
      ErrorHandler.wrap(command: "new") do
        Commands::New.new(options.to_h.transform_keys(&:to_sym)).project(name)
      end
    end

    # === Docs Command ===

    desc "docs", "Generate all documentation"
    long_desc <<~DESC
      Regenerates all API and CLI documentation:
        - JSON files (engine/language/*.json)
        - Markdown files (docs/api/*.md, docs/cli/*.md)
        - HTML files (docs/html/api/*.html, docs/html/cli/*.html)

      This is the same documentation generated during 'gmrcli setup',
      but can be run independently when you've made changes to:
        - C++ binding source files (src/bindings/*.cpp)
        - CLI command files (cli/lib/gmrcli/commands/*.rb)
    DESC
    def docs
      ErrorHandler.wrap(command: "docs") do
        Commands::Docs.new(options.to_h.transform_keys(&:to_sym)).run
      end
    end

    # === Dev Command ===

    desc "dev [TARGET]", "Build and run in one command"
    long_desc <<~DESC
      Streamlined development workflow that builds and runs.

      Targets:
        debug   - Build debug and run (default)
        release - Build release and run
        web     - Clean, build web, and start server (always cleans)

      Options:
        --clean     - Clean before building (for fresh native builds)
        --no-run    - Build only, don't run afterward

      Examples:
        gmrcli dev              # Build debug, run
        gmrcli dev --clean      # Clean, build debug, run
        gmrcli dev release      # Build release, run
        gmrcli dev web          # Clean, build web, start server
    DESC
    option :clean, type: :boolean, default: false,
                   desc: "Clean before building (use --clean for fresh build)"
    option :run, type: :boolean, default: true,
                 desc: "Run after building (use --no-run to skip)"
    option :port, type: :numeric, default: 8080,
                  desc: "Port for web server"
    option :topmost, type: :boolean, default: false,
                     desc: "Keep game window on top of other windows"
    def dev(target = "debug")
      ErrorHandler.wrap(command: "dev") do
        target = target.downcase

        # Validate target
        unless %w[debug release web].include?(target)
          raise Error.new(
            "Unknown dev target: #{target}",
            code: "DEV.INVALID_TARGET",
            suggestions: ["Available: debug, release, web"]
          )
        end

        builder = Commands::Build.new(options.to_h.transform_keys(&:to_sym))
        runner = Commands::Run.new(options.to_h.transform_keys(&:to_sym))

        # Step 1: Clean (always for web, optional for native)
        should_clean = options[:clean] || target == "web"
        if should_clean
          UI.step "Cleaning..."
          builder.clean
        end

        # Step 2: Build
        case target
        when "debug"   then builder.debug
        when "release" then builder.release
        when "web"     then builder.web
        end

        # Step 3: Run (optional)
        if options[:run]
          UI.blank
          UI.step "Running..."
          case target
          when "debug", "release" then runner.native
          when "web" then runner.web
          end
        end
      end
    end

    # === Info Commands ===

    desc "version", "Show gmrcli version"
    def version
      result = {
        gmrcli_version: VERSION,
        protocol_version: Protocol::VERSION,
        platform: Platform.name,
        gmr_root: Platform.gmr_root
      }

      # Emit JSON if in machine mode
      JsonEmitter.emit_success_envelope(command: "version", result: result)

      # Human output
      UI.info "gmrcli #{VERSION}"
      UI.info "Protocol: #{Protocol::VERSION}"
      UI.info "Platform: #{Platform.name}"
      UI.info "GMR root: #{Platform.gmr_root}" if Platform.gmr_engine?(Platform.gmr_root)
    end

    desc "info", "Show environment information"
    def info
      # Collect info for JSON output
      tools_info = {}
      deps_info = {}

      # Collect tools info
      %w[gcc g++ cmake ninja git ruby].each do |tool|
        if Platform.command_exists?(tool)
          version = Shell.capture("#{tool} --version")&.lines&.first&.strip
          tools_info[tool] = { installed: true, version: version || "unknown" }
        else
          tools_info[tool] = { installed: false }
        end
      end

      # Collect dependencies info
      dep_paths = {
        "raylib_native" => File.join(Platform.deps_dir, "raylib", "native", "lib", "libraylib.a"),
        "raylib_web" => File.join(Platform.deps_dir, "raylib", "web", "lib", "libraylib.a"),
        "mruby_native" => File.join(Platform.deps_dir, "mruby", "native", "lib", "libmruby.a"),
        "mruby_web" => File.join(Platform.deps_dir, "mruby", "web", "lib", "libmruby.a"),
        "emsdk" => File.join(Platform.deps_dir, "emsdk")
      }

      dep_paths.each do |name, path|
        installed = File.exist?(path)
        deps_info[name] = { installed: installed }
        deps_info[name][:path] = path if installed
      end

      result = {
        environment: {
          platform: Platform.name,
          platform_id: Platform.id,
          gmr_root: Platform.gmr_root,
          cpu_cores: Platform.nproc
        },
        tools: tools_info,
        dependencies: deps_info
      }

      # Emit JSON result
      JsonEmitter.emit_success_envelope(command: "info", result: result)

      # Human output
      UI.banner

      UI.step "Environment"
      UI.status_line("Platform", Platform.name)
      UI.status_line("GMR root", Platform.gmr_root)
      UI.status_line("CPU cores", Platform.nproc.to_s)

      UI.step "Tools"
      tools_info.each do |tool, info|
        if info[:installed]
          UI.status_line(tool, info[:version] || "installed", ok: true)
        else
          UI.status_line(tool, "not found", ok: false)
        end
      end

      UI.step "Dependencies"
      dep_paths.each do |name, path|
        display_name = name.tr("_", "-")
        UI.status_line(display_name, File.exist?(path) ? "installed" : "not found", ok: File.exist?(path))
      end
    end

    # Make 'start' the default command when no args
    default_task :start
  end
end

# Run the CLI
Gmrcli::CLI.start(ARGV)
