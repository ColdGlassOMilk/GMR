{
  "meta": {
    "version": "1.0.0",
    "engine": "GMR",
    "mrubyVersion": "3.4.0",
    "raylibVersion": "5.6-dev"
  },
  "types": {
    "Color": {
      "kind": "alias",
      "type": "Array<Integer>",
      "description": "RGBA color as [r, g, b] or [r, g, b, a], values 0-255. Alpha defaults to 255 if omitted.",
      "examples": [
        "[255, 0, 0]",
        "[255, 0, 0, 128]"
      ]
    },
    "KeyCode": {
      "kind": "union",
      "types": [
        "Integer",
        "Symbol",
        "Array<Integer|Symbol>"
      ],
      "description": "Key identifier - integer constant (KEY_*), symbol (:space, :a, :left, etc.), or array of keys to check any match",
      "symbols": [
        "space",
        "escape",
        "enter",
        "return",
        "tab",
        "backspace",
        "delete",
        "insert",
        "up",
        "down",
        "left",
        "right",
        "home",
        "end",
        "page_up",
        "page_down",
        "left_shift",
        "right_shift",
        "left_control",
        "right_control",
        "left_alt",
        "right_alt",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "f10",
        "f11",
        "f12",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9"
      ]
    },
    "MouseButton": {
      "kind": "union",
      "types": [
        "Integer",
        "Symbol"
      ],
      "description": "Mouse button identifier - integer constant (MOUSE_*) or symbol",
      "symbols": [
        "left",
        "right",
        "middle",
        "side",
        "extra",
        "forward",
        "back"
      ]
    },
    "Sound": {
      "kind": "class",
      "module": "GMR::Audio::Sound",
      "description": "TODO: Add description"
    },
    "Camera2D": {
      "kind": "class",
      "module": "Camera2D",
      "description": "TODO: Add description"
    },
    "Ease": {
      "kind": "class",
      "module": "GMR::Ease",
      "description": "TODO: Add description"
    },
    "Texture": {
      "kind": "class",
      "module": "GMR::Graphics::Texture",
      "description": "TODO: Add description"
    },
    "Tilemap": {
      "kind": "class",
      "module": "GMR::Graphics::Tilemap",
      "description": "TODO: Add description"
    },
    "Vec2": {
      "kind": "class",
      "module": "Vec2",
      "description": "TODO: Add description"
    },
    "Vec3": {
      "kind": "class",
      "module": "Vec3",
      "description": "TODO: Add description"
    },
    "Rect": {
      "kind": "class",
      "module": "Rect",
      "description": "TODO: Add description"
    },
    "Node": {
      "kind": "class",
      "module": "Node",
      "description": "TODO: Add description"
    },
    "Scene": {
      "kind": "class",
      "module": "GMR::Scene",
      "description": "TODO: Add description"
    },
    "SceneManager": {
      "kind": "class",
      "module": "GMR::SceneManager",
      "description": "TODO: Add description"
    },
    "Sprite": {
      "kind": "class",
      "module": "Sprite",
      "description": "TODO: Add description"
    },
    "SpriteAnimation": {
      "kind": "class",
      "module": "GMR::SpriteAnimation",
      "description": "TODO: Add description"
    },
    "StateMachine": {
      "kind": "class",
      "module": "GMR::StateMachine",
      "description": "TODO: Add description"
    },
    "Transform2D": {
      "kind": "class",
      "module": "Transform2D",
      "description": "TODO: Add description"
    },
    "Tween": {
      "kind": "class",
      "module": "GMR::Tween",
      "description": "TODO: Add description"
    },
    "GMR": {
      "kind": "class",
      "module": "GMR",
      "description": "TODO: Add description"
    }
  },
  "modules": {
    "GMR::Collision": {
      "description": "TODO: Add description",
      "functions": {
        "point_in_rect?": {
          "description": "Check if a point is inside a rectangle.",
          "params": [
            {
              "name": "px",
              "type": "Float",
              "description": "Point X coordinate"
            },
            {
              "name": "py",
              "type": "Float",
              "description": "Point Y coordinate"
            },
            {
              "name": "rx",
              "type": "Float",
              "description": "Rectangle X position (top-left)"
            },
            {
              "name": "ry",
              "type": "Float",
              "description": "Rectangle Y position (top-left)"
            },
            {
              "name": "rw",
              "type": "Float",
              "description": "Rectangle width"
            },
            {
              "name": "rh",
              "type": "Float",
              "description": "Rectangle height"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the point is inside the rectangle"
          },
          "example": "if GMR::Collision.point_in_rect?(mouse_x, mouse_y, btn.x, btn.y, btn.w, btn.h)\n  button_hovered = true\r\nend\r"
        },
        "point_in_circle?": {
          "description": "Check if a point is inside a circle.",
          "params": [
            {
              "name": "px",
              "type": "Float",
              "description": "Point X coordinate"
            },
            {
              "name": "py",
              "type": "Float",
              "description": "Point Y coordinate"
            },
            {
              "name": "cx",
              "type": "Float",
              "description": "Circle center X coordinate"
            },
            {
              "name": "cy",
              "type": "Float",
              "description": "Circle center Y coordinate"
            },
            {
              "name": "radius",
              "type": "Float",
              "description": "Circle radius"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the point is inside the circle"
          },
          "example": "if GMR::Collision.point_in_circle?(x, y, orb.x, orb.y, orb.radius)\n  orb.collect\r\nend\r"
        },
        "rect_overlap?": {
          "description": "Check if two rectangles overlap (AABB collision).",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First rectangle X position"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First rectangle Y position"
            },
            {
              "name": "w1",
              "type": "Float",
              "description": "First rectangle width"
            },
            {
              "name": "h1",
              "type": "Float",
              "description": "First rectangle height"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second rectangle X position"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second rectangle Y position"
            },
            {
              "name": "w2",
              "type": "Float",
              "description": "Second rectangle width"
            },
            {
              "name": "h2",
              "type": "Float",
              "description": "Second rectangle height"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the rectangles overlap"
          },
          "example": "if GMR::Collision.rect_overlap?(player.x, player.y, 32, 48,\n                                         platform.x, platform.y, 64, 16)\r\n  player.on_ground = true\r\nend\r"
        },
        "rect_contains?": {
          "description": "Check if the outer rectangle fully contains the inner rectangle.",
          "params": [
            {
              "name": "outer_x",
              "type": "Float",
              "description": "Outer rectangle X position"
            },
            {
              "name": "outer_y",
              "type": "Float",
              "description": "Outer rectangle Y position"
            },
            {
              "name": "outer_w",
              "type": "Float",
              "description": "Outer rectangle width"
            },
            {
              "name": "outer_h",
              "type": "Float",
              "description": "Outer rectangle height"
            },
            {
              "name": "inner_x",
              "type": "Float",
              "description": "Inner rectangle X position"
            },
            {
              "name": "inner_y",
              "type": "Float",
              "description": "Inner rectangle Y position"
            },
            {
              "name": "inner_w",
              "type": "Float",
              "description": "Inner rectangle width"
            },
            {
              "name": "inner_h",
              "type": "Float",
              "description": "Inner rectangle height"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the inner rectangle is fully inside the outer rectangle"
          },
          "example": "if GMR::Collision.rect_contains?(screen_x, screen_y, screen_w, screen_h,\n                                          entity.x, entity.y, entity.w, entity.h)\r\n  entity.draw  # Only draw if fully on screen\r\nend\r"
        },
        "circle_overlap?": {
          "description": "Check if two circles overlap.",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First circle center X"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First circle center Y"
            },
            {
              "name": "r1",
              "type": "Float",
              "description": "First circle radius"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second circle center X"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second circle center Y"
            },
            {
              "name": "r2",
              "type": "Float",
              "description": "Second circle radius"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the circles overlap"
          },
          "example": "if GMR::Collision.circle_overlap?(ball1.x, ball1.y, ball1.r,\n                                           ball2.x, ball2.y, ball2.r)\r\n  bounce_balls(ball1, ball2)\r\nend\r"
        },
        "circle_rect_overlap?": {
          "description": "Check if a circle overlaps with a rectangle.",
          "params": [
            {
              "name": "cx",
              "type": "Float",
              "description": "Circle center X"
            },
            {
              "name": "cy",
              "type": "Float",
              "description": "Circle center Y"
            },
            {
              "name": "cr",
              "type": "Float",
              "description": "Circle radius"
            },
            {
              "name": "rx",
              "type": "Float",
              "description": "Rectangle X position"
            },
            {
              "name": "ry",
              "type": "Float",
              "description": "Rectangle Y position"
            },
            {
              "name": "rw",
              "type": "Float",
              "description": "Rectangle width"
            },
            {
              "name": "rh",
              "type": "Float",
              "description": "Rectangle height"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the circle and rectangle overlap"
          },
          "example": "if GMR::Collision.circle_rect_overlap?(ball.x, ball.y, ball.r,\n                                                 wall.x, wall.y, wall.w, wall.h)\r\n  ball.bounce\r\nend\r"
        },
        "rect_tiles": {
          "description": "Get all tile coordinates that a rectangle overlaps. Useful for tile-based collision detection.",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "Rectangle X position"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "Rectangle Y position"
            },
            {
              "name": "w",
              "type": "Float",
              "description": "Rectangle width"
            },
            {
              "name": "h",
              "type": "Float",
              "description": "Rectangle height"
            },
            {
              "name": "tile_size",
              "type": "Integer",
              "description": "Size of each tile in pixels"
            }
          ],
          "returns": {
            "type": "Array<Array<Integer>>",
            "description": "Array of [tx, ty] tile coordinate pairs"
          },
          "example": "tiles = GMR::Collision.rect_tiles(player.x, player.y, 32, 48, 16)\n  tiles.each do |tx, ty|\r\n    if tilemap.solid?(tx, ty)\r\n      # Handle collision with this tile\r\n    end\r\n  end\r"
        },
        "tile_rect": {
          "description": "Convert tile coordinates to a world-space rectangle.",
          "params": [
            {
              "name": "tx",
              "type": "Integer",
              "description": "Tile X coordinate"
            },
            {
              "name": "ty",
              "type": "Integer",
              "description": "Tile Y coordinate"
            },
            {
              "name": "tile_size",
              "type": "Integer",
              "description": "Size of each tile in pixels"
            }
          ],
          "returns": {
            "type": "Array<Integer>",
            "description": "Rectangle as [x, y, width, height]"
          },
          "example": "x, y, w, h = GMR::Collision.tile_rect(5, 3, 16)\n  # Returns [80, 48, 16, 16]\r"
        },
        "distance": {
          "description": "Calculate the Euclidean distance between two points.",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First point X"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First point Y"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second point X"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second point Y"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Distance between the points"
          },
          "example": "dist = GMR::Collision.distance(player.x, player.y, enemy.x, enemy.y)\n  if dist < attack_range\r\n    attack_enemy(enemy)\r\n  end\r"
        },
        "distance_squared": {
          "description": "Calculate the squared distance between two points. Faster than distance() since it avoids the square root. Use for comparisons.",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First point X"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First point Y"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second point X"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second point Y"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Squared distance between the points"
          },
          "example": "# More efficient for distance comparisons\n  dist_sq = GMR::Collision.distance_squared(a.x, a.y, b.x, b.y)\r\n  if dist_sq < range * range\r\n    in_range = true\r\n  end\r"
        }
      }
    },
    "GMR::Graphics": {
      "description": "TODO: Add description",
      "functions": {
        "clear": {
          "signature": "clear(color)",
          "description": "Clear the screen with a solid color",
          "params": [
            {
              "name": "color",
              "type": "Color",
              "description": "The background color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.clear([20, 20, 40])"
        },
        "draw_rect": {
          "signature": "draw_rect(x, y, w, h, color)",
          "description": "Draw a filled rectangle",
          "params": [
            {
              "name": "x",
              "type": "Integer",
              "description": "X position (left edge)"
            },
            {
              "name": "y",
              "type": "Integer",
              "description": "Y position (top edge)"
            },
            {
              "name": "w",
              "type": "Integer",
              "description": "Width in pixels"
            },
            {
              "name": "h",
              "type": "Integer",
              "description": "Height in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Fill color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_rect(100, 100, 50, 30, [255, 0, 0])"
        },
        "draw_rect_outline": {
          "signature": "draw_rect_outline(x, y, w, h, color)",
          "description": "Draw a rectangle outline (not filled)",
          "params": [
            {
              "name": "x",
              "type": "Integer",
              "description": "X position (left edge)"
            },
            {
              "name": "y",
              "type": "Integer",
              "description": "Y position (top edge)"
            },
            {
              "name": "w",
              "type": "Integer",
              "description": "Width in pixels"
            },
            {
              "name": "h",
              "type": "Integer",
              "description": "Height in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Outline color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_rect_outline(100, 100, 50, 30, [255, 255, 255])"
        },
        "draw_rect_rotated": {
          "signature": "draw_rect_rotated(x, y, w, h, angle, color)",
          "description": "Draw a filled rectangle rotated around its center",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "X position (center)"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "Y position (center)"
            },
            {
              "name": "w",
              "type": "Float",
              "description": "Width in pixels"
            },
            {
              "name": "h",
              "type": "Float",
              "description": "Height in pixels"
            },
            {
              "name": "angle",
              "type": "Float",
              "description": "Rotation angle in degrees"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Fill color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_rect_rotated(160, 120, 40, 20, 45.0, [0, 255, 0])"
        },
        "draw_line": {
          "signature": "draw_line(x1, y1, x2, y2, color)",
          "description": "Draw a line between two points",
          "params": [
            {
              "name": "x1",
              "type": "Integer",
              "description": "Start X position"
            },
            {
              "name": "y1",
              "type": "Integer",
              "description": "Start Y position"
            },
            {
              "name": "x2",
              "type": "Integer",
              "description": "End X position"
            },
            {
              "name": "y2",
              "type": "Integer",
              "description": "End Y position"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Line color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_line(0, 0, 100, 100, [255, 255, 255])"
        },
        "draw_line_thick": {
          "signature": "draw_line_thick(x1, y1, x2, y2, thickness, color)",
          "description": "Draw a thick line between two points",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "Start X position"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "Start Y position"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "End X position"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "End Y position"
            },
            {
              "name": "thickness",
              "type": "Float",
              "description": "Line thickness in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Line color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_line_thick(0, 0, 100, 100, 3.0, [255, 200, 100])"
        },
        "draw_circle": {
          "signature": "draw_circle(x, y, radius, color)",
          "description": "Draw a filled circle",
          "params": [
            {
              "name": "x",
              "type": "Integer",
              "description": "Center X position"
            },
            {
              "name": "y",
              "type": "Integer",
              "description": "Center Y position"
            },
            {
              "name": "radius",
              "type": "Integer",
              "description": "Circle radius in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Fill color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_circle(160, 120, 25, [100, 200, 255])"
        },
        "draw_circle_outline": {
          "signature": "draw_circle_outline(x, y, radius, color)",
          "description": "Draw a circle outline",
          "params": [
            {
              "name": "x",
              "type": "Integer",
              "description": "Center X position"
            },
            {
              "name": "y",
              "type": "Integer",
              "description": "Center Y position"
            },
            {
              "name": "radius",
              "type": "Integer",
              "description": "Circle radius in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Outline color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_circle_outline(160, 120, 25, [255, 255, 255])"
        },
        "draw_circle_gradient": {
          "signature": "draw_circle_gradient(x, y, radius, inner_color, outer_color)",
          "description": "Draw a circle with a radial gradient from inner to outer color",
          "params": [
            {
              "name": "x",
              "type": "Integer",
              "description": "Center X position"
            },
            {
              "name": "y",
              "type": "Integer",
              "description": "Center Y position"
            },
            {
              "name": "radius",
              "type": "Integer",
              "description": "Circle radius in pixels"
            },
            {
              "name": "inner_color",
              "type": "Color",
              "description": "Color at center"
            },
            {
              "name": "outer_color",
              "type": "Color",
              "description": "Color at edge"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_circle_gradient(160, 120, 50, [255, 255, 255], [255, 0, 0, 0])"
        },
        "draw_triangle": {
          "signature": "draw_triangle(x1, y1, x2, y2, x3, y3, color)",
          "description": "Draw a filled triangle",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First vertex X"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First vertex Y"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second vertex X"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second vertex Y"
            },
            {
              "name": "x3",
              "type": "Float",
              "description": "Third vertex X"
            },
            {
              "name": "y3",
              "type": "Float",
              "description": "Third vertex Y"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Fill color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_triangle(100, 50, 50, 150, 150, 150, [255, 0, 0])"
        },
        "draw_triangle_outline": {
          "signature": "draw_triangle_outline(x1, y1, x2, y2, x3, y3, color)",
          "description": "Draw a triangle outline",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First vertex X"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First vertex Y"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second vertex X"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second vertex Y"
            },
            {
              "name": "x3",
              "type": "Float",
              "description": "Third vertex X"
            },
            {
              "name": "y3",
              "type": "Float",
              "description": "Third vertex Y"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Outline color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_triangle_outline(100, 50, 50, 150, 150, 150, [255, 255, 255])"
        },
        "draw_text": {
          "signature": "draw_text(text, x, y, size, color)",
          "description": "Draw text at a position",
          "params": [
            {
              "name": "text",
              "type": "String",
              "description": "The text to draw"
            },
            {
              "name": "x",
              "type": "Integer",
              "description": "X position (left edge)"
            },
            {
              "name": "y",
              "type": "Integer",
              "description": "Y position (top edge)"
            },
            {
              "name": "size",
              "type": "Integer",
              "description": "Font size in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Text color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_text(\"Hello!\", 10, 10, 20, [255, 255, 255])"
        },
        "measure_text": {
          "signature": "measure_text(text, size)",
          "description": "A loaded image texture for drawing sprites and images",
          "params": [
            {
              "name": "text",
              "type": "String",
              "description": "The text to measure"
            },
            {
              "name": "size",
              "type": "Integer",
              "description": "Font size in pixels"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Width in pixels"
          },
          "example": "width = GMR::Graphics.measure_text(\"Hello\", 20)"
        }
      }
    },
    "GMR::Input": {
      "description": "TODO: Add description",
      "functions": {
        "mouse_x": {
          "description": "Get the mouse X position in virtual resolution coordinates. Automatically accounts for letterboxing when using virtual resolution.",
          "returns": {
            "type": "Integer",
            "description": "Mouse X position"
          },
          "example": "x = GMR::Input.mouse_x"
        },
        "mouse_y": {
          "description": "Get the mouse Y position in virtual resolution coordinates. Automatically accounts for letterboxing when using virtual resolution.",
          "returns": {
            "type": "Integer",
            "description": "Mouse Y position"
          },
          "example": "y = GMR::Input.mouse_y"
        },
        "mouse_down?": {
          "description": "Check if a mouse button is currently held down.",
          "params": [
            {
              "name": "button",
              "type": "Symbol, Integer",
              "description": "The button to check (:left, :right, :middle, or constant)"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the button is held"
          },
          "example": "if GMR::Input.mouse_down?(:left)\n  player.aim\nend"
        },
        "mouse_pressed?": {
          "description": "Check if a mouse button was just pressed this frame.",
          "params": [
            {
              "name": "button",
              "type": "Symbol, Integer",
              "description": "The button to check (:left, :right, :middle, or constant)"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the button was just pressed"
          },
          "example": "if GMR::Input.mouse_pressed?(:left)\n  player.shoot\nend"
        },
        "mouse_released?": {
          "description": "Check if a mouse button was just released this frame.",
          "params": [
            {
              "name": "button",
              "type": "Symbol, Integer",
              "description": "The button to check (:left, :right, :middle, or constant)"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the button was just released"
          },
          "example": "if GMR::Input.mouse_released?(:left)\n  bow.release_arrow\nend"
        },
        "mouse_wheel": {
          "description": "Get the mouse wheel movement this frame. Positive values indicate scrolling up/forward, negative values indicate scrolling down/backward.",
          "returns": {
            "type": "Float",
            "description": "Wheel movement amount"
          },
          "example": "zoom += GMR::Input.mouse_wheel * 0.1"
        },
        "key_down?": {
          "description": "Check if a key is currently held down. Accepts a single key or an array of keys (returns true if any key in the array is held).",
          "params": [
            {
              "name": "key",
              "type": "Symbol, Integer, Array",
              "description": "The key(s) to check (:space, :a, :left, etc.)"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the key (or any key in array) is held"
          },
          "example": "if GMR::Input.key_down?([:a, :left])  # Either key works\n  player.move_left\nend"
        },
        "key_pressed?": {
          "description": "Check if a key was just pressed this frame. Accepts a single key or an array of keys (returns true if any key in the array was just pressed).",
          "params": [
            {
              "name": "key",
              "type": "Symbol, Integer, Array",
              "description": "The key(s) to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the key (or any key in array) was just pressed"
          },
          "example": "if GMR::Input.key_pressed?(:space)\n  player.jump\nend"
        },
        "key_released?": {
          "description": "Check if a key was just released this frame. Accepts a single key or an array of keys (returns true if any key in the array was just released).",
          "params": [
            {
              "name": "key",
              "type": "Symbol, Integer, Array",
              "description": "The key(s) to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the key (or any key in array) was just released"
          },
          "example": "if GMR::Input.key_released?(:shift)\n  player.stop_running\nend"
        },
        "key_pressed": {
          "description": "Get the key code of the last key pressed this frame. Useful for text input or detecting any key press.",
          "returns": {
            "type": "Integer, nil",
            "description": "Key code, or nil if no key was pressed"
          },
          "example": "key = GMR::Input.key_pressed\n  if key\n    puts \"Key code: #{key}\"\n  end"
        },
        "char_pressed": {
          "description": "Get the Unicode character code of the last character pressed this frame. Useful for text input fields. Returns the character, not the key code.",
          "returns": {
            "type": "Integer, nil",
            "description": "Unicode character code, or nil if no character was pressed"
          },
          "example": "char = GMR::Input.char_pressed\n  if char"
        },
        "map": {
          "description": "Map an action name to input bindings. Supports two forms: Traditional form maps a single action to keys directly. Block form allows defining multiple actions with a DSL.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "(optional) The action name for traditional form"
            },
            {
              "name": "keys",
              "type": "Symbol, Array",
              "description": "(optional) Key(s) to bind for traditional form"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "# Block DSL form\n  GMR::Input.map do |i|\n    i.action :jump, key: :space\n    i.action :attack, keys: [:z, :x], mouse: :left\n  end"
        },
        "unmap": {
          "description": "Remove an action mapping by name.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The action name to remove"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Input.unmap(:jump)"
        },
        "clear_mappings": {
          "description": "Remove all action mappings.",
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Input.clear_mappings"
        },
        "action_down?": {
          "description": "Check if a mapped action is currently active (any bound input is held).",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The action name to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the action is active"
          },
          "example": "if GMR::Input.action_down?(:move_left)\n  player.x -= speed\nend"
        },
        "action_pressed?": {
          "description": "Check if a mapped action was just triggered this frame.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The action name to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the action was just triggered"
          },
          "example": "if GMR::Input.action_pressed?(:jump)\n  player.jump\nend"
        },
        "action_released?": {
          "description": "Check if a mapped action was just released this frame.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The action name to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the action was just released"
          },
          "example": "if GMR::Input.action_released?(:charge_attack)\n  player.release_charge\nend"
        },
        "on": {
          "description": "Register a callback for an action. The callback fires when the action reaches the specified phase. Returns an ID for later removal with `off`.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The action name to listen for"
            },
            {
              "name": "when",
              "type": "Symbol",
              "description": "(optional, default: :pressed) Phase: :pressed, :down, or :released"
            },
            {
              "name": "context",
              "type": "Object",
              "description": "(optional) Object to use as self in the callback block"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Callback ID for later removal"
          },
          "example": "# With phase and context\n  id = GMR::Input.on(:attack, when: :released, context: player) do\n    release_charge_attack\n  end\n  GMR::Input.off(id)  # Remove later"
        },
        "off": {
          "description": "Remove input callback(s). Pass an ID to remove a specific callback, or an action name to remove all callbacks for that action.",
          "params": [
            {
              "name": "id_or_action",
              "type": "Integer, Symbol",
              "description": "Callback ID or action name"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Input.off(:jump)        # Remove all :jump callbacks"
        },
        "push_context": {
          "description": "Push a named input context onto the stack. Actions defined in this context become active. Previous contexts remain on the stack.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The context name to push"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Input.push_context(:menu)\n  # :menu actions are now active, game actions still on stack"
        },
        "pop_context": {
          "description": "Pop the current input context from the stack, returning to the previous context.",
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Input.pop_context  # Return to previous context"
        },
        "set_context": {
          "description": "Replace the entire context stack with a single context. Clears the stack and sets the named context as the only active context.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The context name to set"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Input.set_context(:gameplay)"
        },
        "current_context": {
          "description": "Get the name of the current active input context.",
          "returns": {
            "type": "Symbol, nil",
            "description": "Current context name, or nil if no context is active"
          },
          "example": "context = GMR::Input.current_context"
        },
        "has_context?": {
          "description": "Check if a named input context exists (has been defined).",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The context name to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the context exists"
          },
          "example": "if GMR::Input.has_context?(:menu)\n  GMR::Input.push_context(:menu)\nend"
        },
        "input": {
          "description": "Define global input actions using a verb-style DSL. Actions defined here are always available regardless of context.",
          "returns": {
            "type": "nil"
          },
          "example": "input do |i|\n  i.jump :space\n  i.move_left [:a, :left]\n  i.attack :z, mouse: :left\nend"
        },
        "input_context": {
          "description": "Define input actions for a named context. Context-specific actions are only active when that context is pushed onto the stack.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The context name"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "input_context :menu do |i|\n  i.confirm :enter\n  i.cancel :escape\n  i.navigate_up :up\n  i.navigate_down :down\nend"
        }
      }
    },
    "GMR::System": {
      "description": "TODO: Add description",
      "functions": {
        "random_int": {
          "description": "Generate a random integer within an inclusive range.",
          "params": [
            {
              "name": "min",
              "type": "Integer",
              "description": "Minimum value (inclusive)"
            },
            {
              "name": "max",
              "type": "Integer",
              "description": "Maximum value (inclusive)"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Random integer between min and max"
          },
          "example": "dice = GMR::System.random_int(1, 6)"
        },
        "random_float": {
          "description": "Generate a random float between 0.0 and 1.0.",
          "returns": {
            "type": "Float",
            "description": "Random float in range [0.0, 1.0]"
          },
          "example": "chance = GMR::System.random_float\n  critical_hit = chance > 0.9"
        },
        "quit": {
          "description": "Immediately exit the application. Closes the window and terminates the process.",
          "returns": {
            "type": "nil"
          },
          "example": "GMR::System.quit  # Exit the game"
        },
        "platform": {
          "description": "Get the current platform identifier.",
          "returns": {
            "type": "String",
            "description": "Platform name: \"windows\", \"macos\", \"linux\", \"web\", or \"unknown\""
          },
          "example": "if GMR::System.platform == \"web\"\n  # Disable desktop-only features\nend"
        },
        "build_type": {
          "description": "Get the build configuration type.",
          "returns": {
            "type": "String",
            "description": "Build type: \"debug\", \"release\", or \"unknown\""
          },
          "example": "if GMR::System.build_type == \"debug\"\n  enable_debug_overlay\nend"
        },
        "compiled_scripts?": {
          "description": "Check if scripts were precompiled into the binary.",
          "returns": {
            "type": "Boolean",
            "description": "true if scripts are compiled in, false if loading from files"
          },
          "example": "puts \"Scripts compiled: #{GMR::System.compiled_scripts?}\""
        },
        "raylib_version": {
          "description": "Get the version of the underlying Raylib graphics library.",
          "returns": {
            "type": "String",
            "description": "Raylib version string (e.g., \"5.0\")"
          },
          "example": "puts \"Raylib: #{GMR::System.raylib_version}\""
        },
        "gpu_vendor": {
          "description": "Get the GPU vendor name from OpenGL.",
          "returns": {
            "type": "String",
            "description": "GPU vendor name (e.g., \"NVIDIA Corporation\") or \"unknown\""
          },
          "example": "puts \"GPU Vendor: #{GMR::System.gpu_vendor}\""
        },
        "gpu_renderer": {
          "description": "Get the GPU renderer name from OpenGL.",
          "returns": {
            "type": "String",
            "description": "GPU renderer name (e.g., \"GeForce RTX 3080\") or \"WebGL\""
          },
          "example": "puts \"GPU: #{GMR::System.gpu_renderer}\""
        },
        "gl_version": {
          "description": "Get the OpenGL version string.",
          "returns": {
            "type": "String",
            "description": "OpenGL version (e.g., \"4.6.0\") or \"WebGL 2.0\""
          },
          "example": "puts \"OpenGL: #{GMR::System.gl_version}\""
        },
        "glsl_version": {
          "description": "Get the GLSL (shader language) version string.",
          "returns": {
            "type": "String",
            "description": "GLSL version (e.g., \"4.60\") or \"GLSL ES 3.00\""
          },
          "example": "puts \"GLSL: #{GMR::System.glsl_version}\""
        },
        "last_error": {
          "description": "Get details about the last script error. Returns nil if no error occurred.",
          "returns": {
            "type": "Hash, nil",
            "description": "Error hash with keys :class, :message, :file, :line, :backtrace, or nil"
          },
          "example": "error = GMR::System.last_error\n  if error\n    puts \"#{error[:class]}: #{error[:message]}\"\n    puts \"  at #{error[:file]}:#{error[:line]}\"\n    error[:backtrace].each { |line| puts \"    #{line}\" }\n  end"
        },
        "in_error_state?": {
          "description": "Check if the scripting engine is currently in an error state.",
          "returns": {
            "type": "Boolean",
            "description": "true if an unhandled error has occurred"
          },
          "example": "if GMR::System.in_error_state?\n  show_error_screen\nend"
        }
      }
    },
    "GMR::Window": {
      "description": "TODO: Add description",
      "functions": {
        "width": {
          "description": "Get the logical width of the game screen. Returns virtual resolution width if set, otherwise the actual window width.",
          "returns": {
            "type": "Integer",
            "description": "Screen width in pixels"
          },
          "example": "screen_w = GMR::Window.width"
        },
        "height": {
          "description": "Get the logical height of the game screen. Returns virtual resolution height if set, otherwise the actual window height.",
          "returns": {
            "type": "Integer",
            "description": "Screen height in pixels"
          },
          "example": "screen_h = GMR::Window.height"
        },
        "actual_width": {
          "description": "Get the actual window width in pixels, ignoring virtual resolution.",
          "returns": {
            "type": "Integer",
            "description": "Actual window width"
          },
          "example": "real_w = GMR::Window.actual_width"
        },
        "actual_height": {
          "description": "Get the actual window height in pixels, ignoring virtual resolution.",
          "returns": {
            "type": "Integer",
            "description": "Actual window height"
          },
          "example": "real_h = GMR::Window.actual_height"
        },
        "set_size": {
          "description": "Set the window size. Has no effect in fullscreen mode.",
          "params": [
            {
              "name": "w",
              "type": "Integer",
              "description": "Window width in pixels"
            },
            {
              "name": "h",
              "type": "Integer",
              "description": "Window height in pixels"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Window.set_size(1280, 720)"
        },
        "set_title": {
          "description": "Set the window title bar text.",
          "params": [
            {
              "name": "title",
              "type": "String",
              "description": "The window title"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Window.set_title(\"My Awesome Game\")"
        },
        "toggle_fullscreen": {
          "description": "Toggle between fullscreen and windowed mode.",
          "returns": {
            "type": "Boolean",
            "description": "true"
          },
          "example": "GMR::Window.toggle_fullscreen"
        },
        "fullscreen=": {
          "description": "Set fullscreen mode on or off.",
          "params": [
            {
              "name": "fullscreen",
              "type": "Boolean",
              "description": "true for fullscreen, false for windowed"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "The fullscreen state that was set"
          },
          "example": "GMR::Window.fullscreen = true"
        },
        "fullscreen?": {
          "description": "Check if the window is currently in fullscreen mode.",
          "returns": {
            "type": "Boolean",
            "description": "true if fullscreen"
          },
          "example": "if GMR::Window.fullscreen?\n  show_windowed_mode_button\nend"
        },
        "set_virtual_resolution": {
          "description": "Set a virtual resolution for pixel-perfect rendering. The game renders to this resolution and scales to fit the window with letterboxing.",
          "params": [
            {
              "name": "w",
              "type": "Integer",
              "description": "Virtual width in pixels"
            },
            {
              "name": "h",
              "type": "Integer",
              "description": "Virtual height in pixels"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true"
          },
          "example": "# Render at 320x240 for retro-style game\n  GMR::Window.set_virtual_resolution(320, 240)"
        },
        "clear_virtual_resolution": {
          "description": "Disable virtual resolution and render directly at window size.",
          "returns": {
            "type": "Boolean",
            "description": "true"
          },
          "example": "GMR::Window.clear_virtual_resolution"
        },
        "virtual_resolution?": {
          "description": "Check if virtual resolution is currently enabled.",
          "returns": {
            "type": "Boolean",
            "description": "true if virtual resolution is active"
          },
          "example": "if GMR::Window.virtual_resolution?\n  puts \"Using virtual resolution\"\nend"
        },
        "set_filter_point": {
          "description": "Set nearest-neighbor (point) filtering for virtual resolution scaling. Produces crisp, pixelated look. Only works when virtual resolution is enabled.",
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Window.set_filter_point  # For pixel art games"
        },
        "set_filter_bilinear": {
          "description": "Set bilinear filtering for virtual resolution scaling. Produces smoother, blended scaling. Only works when virtual resolution is enabled.",
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Window.set_filter_bilinear  # For smoother scaling"
        },
        "monitor_count": {
          "description": "Get the number of connected monitors.",
          "returns": {
            "type": "Integer",
            "description": "Number of monitors"
          },
          "example": "count = GMR::Window.monitor_count"
        },
        "monitor_width": {
          "description": "Get the width of a specific monitor.",
          "params": [
            {
              "name": "index",
              "type": "Integer",
              "description": "Monitor index (0-based)"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Monitor width in pixels"
          },
          "example": "w = GMR::Window.monitor_width(0)  # Primary monitor"
        },
        "monitor_height": {
          "description": "Get the height of a specific monitor.",
          "params": [
            {
              "name": "index",
              "type": "Integer",
              "description": "Monitor index (0-based)"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Monitor height in pixels"
          },
          "example": "h = GMR::Window.monitor_height(0)"
        },
        "monitor_refresh_rate": {
          "description": "Get the refresh rate of a specific monitor.",
          "params": [
            {
              "name": "index",
              "type": "Integer",
              "description": "Monitor index (0-based)"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Refresh rate in Hz"
          },
          "example": "hz = GMR::Window.monitor_refresh_rate(0)"
        },
        "monitor_name": {
          "description": "Time and frame rate utilities. Provides delta time for frame-independent movement, elapsed time tracking, and FPS management.",
          "params": [
            {
              "name": "index",
              "type": "Integer",
              "description": "Monitor index (0-based)"
            }
          ],
          "returns": {
            "type": "String",
            "description": "Monitor name"
          },
          "example": "# Debug overlay with FPS and timing info\n  class DebugOverlay\n    def draw\n      y = 10\n      color = [0, 255, 0]\n\n      # Show current FPS\n      fps = GMR::Time.fps\n      fps_color = fps < 30 ? [255, 0, 0] : fps < 55 ? [255, 255, 0] : [0, 255, 0]\n      GMR::Graphics.draw_text(\"FPS: #{fps}\", 10, y, 16, fps_color)\n      y += 20\n\n      # Show frame time\n      frame_ms = (GMR::Time.delta * 1000).round(2)\n      GMR::Graphics.draw_text(\"Frame: #{frame_ms}ms\", 10, y, 16, color)\n      y += 20\n\n      # Show total elapsed time\n      elapsed = GMR::Time.elapsed\n      minutes = (elapsed / 60).to_i\n      seconds = (elapsed % 60).to_i\n      GMR::Graphics.draw_text(\"Time: #{minutes}:#{seconds.to_s.rjust(2, '0')}\", 10, y, 16, color)\n    end\n  end"
        }
      }
    },
    "GMR::Time": {
      "description": "TODO: Add description",
      "functions": {
        "delta": {
          "description": "Get the time elapsed since the last frame in seconds. Use this for frame-independent movement and animation.",
          "returns": {
            "type": "Float",
            "description": "Delta time in seconds"
          },
          "example": "# Move at 100 pixels per second regardless of frame rate\n  player.x += 100 * GMR::Time.delta"
        },
        "elapsed": {
          "description": "Get the total time elapsed since the game started in seconds.",
          "returns": {
            "type": "Float",
            "description": "Total elapsed time in seconds"
          },
          "example": "# Flash effect every 0.5 seconds\n  visible = (GMR::Time.elapsed % 1.0) < 0.5"
        },
        "fps": {
          "description": "Get the current frames per second.",
          "returns": {
            "type": "Integer",
            "description": "Current FPS"
          },
          "example": "puts \"FPS: #{GMR::Time.fps}\""
        },
        "set_target_fps": {
          "description": "Set the target frame rate. The game will try to maintain this FPS. Set to 0 for unlimited frame rate.",
          "params": [
            {
              "name": "fps",
              "type": "Integer",
              "description": "Target frames per second"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Time.set_target_fps(60)  # Lock to 60 FPS"
        }
      }
    },
    "GMR::Audio::Sound": {
      "kind": "class",
      "description": "TODO: Add description",
      "classMethods": {
        "load": {
          "description": "Load a sound file from disk. Supports WAV, OGG, MP3, and other formats.",
          "params": [
            {
              "name": "path",
              "type": "String",
              "description": "Path to the audio file"
            }
          ],
          "returns": {
            "type": "Sound",
            "description": "The loaded sound object"
          },
          "raises": [
            "RuntimeError If the file cannot be loaded"
          ],
          "example": "jump_sound = GMR::Audio::Sound.load(\"assets/sfx/jump.wav\")"
        }
      },
      "instanceMethods": {
        "play": {
          "description": "Play the sound. Can be called multiple times for overlapping playback.",
          "returns": {
            "type": "nil"
          },
          "example": "sound.play"
        },
        "stop": {
          "description": "Stop the sound if it's currently playing.",
          "returns": {
            "type": "nil"
          },
          "example": "sound.stop"
        },
        "volume=": {
          "description": "Set the playback volume for this sound.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "Volume level from 0.0 (silent) to 1.0 (full volume)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The volume that was set"
          },
          "example": "sound.volume = 0.5  # Half volume"
        }
      }
    },
    "Camera2D": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Camera2D with optional initial values.",
          "params": [
            {
              "name": "target",
              "type": "Vec2",
              "description": "World position the camera looks at (default: 0,0)"
            },
            {
              "name": "offset",
              "type": "Vec2",
              "description": "Screen position offset, typically screen center (default: 0,0)"
            },
            {
              "name": "zoom",
              "type": "Float",
              "description": "Zoom level, 1.0 = normal (default: 1.0)"
            },
            {
              "name": "rotation",
              "type": "Float",
              "description": "Rotation in degrees (default: 0)"
            }
          ],
          "returns": {
            "type": "Camera2D",
            "description": "The new camera"
          },
          "example": "cam = Camera2D.new(offset: Vec2.new(400, 300))  # Center on 800x600 screen"
        },
        "target": {
          "description": "Get the world position the camera is looking at.",
          "returns": {
            "type": "Vec2",
            "description": "The camera's target position"
          },
          "example": "target = camera.target"
        },
        "offset": {
          "description": "Get the screen position offset (where the target appears on screen). Typically set to screen center for centered camera following.",
          "returns": {
            "type": "Vec2",
            "description": "The camera's offset position"
          },
          "example": "offset = camera.offset"
        },
        "zoom": {
          "description": "Get the zoom level. 1.0 = normal, 2.0 = 2x magnification, 0.5 = zoomed out.",
          "returns": {
            "type": "Float",
            "description": "The zoom level"
          },
          "example": "z = camera.zoom"
        },
        "rotation": {
          "description": "Get the camera rotation in degrees.",
          "returns": {
            "type": "Float",
            "description": "The rotation angle"
          },
          "example": "angle = camera.rotation"
        },
        "target=": {
          "description": "Set the world position the camera looks at.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The target position"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "camera.target = player.position"
        },
        "offset=": {
          "description": "Set the screen position offset. The target appears at this screen position. Set to screen center for centered following.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The offset position"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "camera.offset = Vec2.new(400, 300)  # Center on 800x600 screen"
        },
        "zoom=": {
          "description": "Set the zoom level. 1.0 = normal, 2.0 = 2x magnification, 0.5 = zoomed out.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The zoom level (must be > 0)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "camera.zoom = 0.5    # Zoom out (see more of the world)"
        },
        "rotation=": {
          "description": "Set the camera rotation in degrees.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The rotation angle in degrees"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "camera.rotation += 10 * dt  # Rotate over time"
        },
        "follow": {
          "description": "Configure the camera to follow a target object with optional smoothing and deadzone. The target must respond to `position` (returning Vec2) or have `x`/`y` methods. Call with nil to stop following.",
          "params": [
            {
              "name": "target",
              "type": "Object, nil",
              "description": "Object with position/x/y to follow, or nil to stop"
            },
            {
              "name": "smoothing",
              "type": "Float",
              "description": "Smoothing factor 0-1 (0=instant, 0.1=smooth, default: 0)"
            },
            {
              "name": "deadzone",
              "type": "Rect",
              "description": "Rectangle where target can move without camera moving"
            }
          ],
          "returns": {
            "type": "Camera2D",
            "description": "self for chaining"
          },
          "example": "# Stop following\n  camera.follow(nil)\r"
        },
        "bounds=": {
          "description": "Set camera bounds to constrain movement within a world region. The camera will not show areas outside these bounds. Set to nil to remove bounds.",
          "params": [
            {
              "name": "value",
              "type": "Rect, nil",
              "description": "The world bounds, or nil to remove"
            }
          ],
          "returns": {
            "type": "Rect, nil",
            "description": "The value that was set"
          },
          "example": "camera.bounds = nil  # No bounds"
        },
        "bounds": {
          "description": "Get the current camera bounds. Returns nil if no bounds are set.",
          "returns": {
            "type": "Rect, nil",
            "description": "The world bounds, or nil if unbounded"
          },
          "example": "rect = camera.bounds"
        },
        "shake": {
          "description": "Trigger a screen shake effect. The shake decays over the duration.",
          "params": [
            {
              "name": "strength",
              "type": "Float",
              "description": "Maximum shake offset in pixels (default: 5.0)"
            },
            {
              "name": "duration",
              "type": "Float",
              "description": "How long the shake lasts in seconds (default: 0.3)"
            },
            {
              "name": "frequency",
              "type": "Float",
              "description": "Shake oscillation frequency in Hz (default: 30.0)"
            }
          ],
          "returns": {
            "type": "Camera2D",
            "description": "self for chaining"
          },
          "example": "camera.shake(strength: 3, duration: 0.2, frequency: 20)"
        },
        "world_to_screen": {
          "description": "Convert a world position to screen coordinates. Useful for placing UI elements relative to game objects.",
          "params": [
            {
              "name": "position",
              "type": "Vec2",
              "description": "The world position"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The screen position"
          },
          "example": "health_bar_x = camera.world_to_screen(enemy.position).x"
        },
        "screen_to_world": {
          "description": "Convert a screen position to world coordinates. Useful for mouse picking and click-to-move.",
          "params": [
            {
              "name": "position",
              "type": "Vec2",
              "description": "The screen position"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The world position"
          },
          "example": "click_target = camera.screen_to_world(Vec2.new(mouse_x, mouse_y))"
        },
        "use": {
          "description": "Execute a block with this camera's transform applied. All drawing within the block will be transformed by the camera (position, zoom, rotation). The camera mode is automatically ended when the block completes.",
          "returns": {
            "type": "Object",
            "description": "The return value of the block"
          },
          "example": "# Nested cameras\n  world_camera.use do\r\n    draw_world()\r\n  end\r\n  # UI drawn outside camera (screen space)\r\n  draw_ui()\r"
        },
        "current=": {
          "description": "Set the current active camera (class method). This camera will be used for sprite rendering and coordinate transformations.",
          "params": [
            {
              "name": "value",
              "type": "Camera2D, nil",
              "description": "The camera to make current, or nil to clear"
            }
          ],
          "returns": {
            "type": "Camera2D, nil",
            "description": "The value that was set"
          },
          "example": "Camera2D.current = nil  # No camera"
        },
        "current": {
          "description": "Get the current active camera (class method). Returns nil if no camera is set.",
          "returns": {
            "type": "Camera2D, nil",
            "description": "The current camera, or nil"
          },
          "example": "cam = Camera2D.current"
        }
      }
    },
    "GMR::Ease": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "linear": {
          "description": "Linear interpolation (no easing). Constant speed throughout.",
          "returns": {
            "type": "Symbol",
            "description": ":linear"
          }
        },
        "in_quad": {
          "description": "Quadratic ease-in. Starts slow, accelerates.",
          "returns": {
            "type": "Symbol",
            "description": ":in_quad"
          }
        },
        "out_quad": {
          "description": "Quadratic ease-out. Starts fast, decelerates.",
          "returns": {
            "type": "Symbol",
            "description": ":out_quad"
          }
        },
        "in_out_quad": {
          "description": "Quadratic ease-in-out. Slow start and end, fast middle.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_quad"
          }
        },
        "in_cubic": {
          "description": "Cubic ease-in. Starts slow, accelerates more than quadratic.",
          "returns": {
            "type": "Symbol",
            "description": ":in_cubic"
          }
        },
        "out_cubic": {
          "description": "Cubic ease-out. Starts fast, decelerates smoothly. Most common.",
          "returns": {
            "type": "Symbol",
            "description": ":out_cubic"
          }
        },
        "in_out_cubic": {
          "description": "Cubic ease-in-out. Smooth acceleration and deceleration.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_cubic"
          }
        },
        "in_quart": {
          "description": "Quartic ease-in. Dramatic slow start.",
          "returns": {
            "type": "Symbol",
            "description": ":in_quart"
          }
        },
        "out_quart": {
          "description": "Quartic ease-out. Dramatic fast start.",
          "returns": {
            "type": "Symbol",
            "description": ":out_quart"
          }
        },
        "in_out_quart": {
          "description": "Quartic ease-in-out.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_quart"
          }
        },
        "in_sine": {
          "description": "Sinusoidal ease-in. Gentle acceleration.",
          "returns": {
            "type": "Symbol",
            "description": ":in_sine"
          }
        },
        "out_sine": {
          "description": "Sinusoidal ease-out. Gentle deceleration.",
          "returns": {
            "type": "Symbol",
            "description": ":out_sine"
          }
        },
        "in_out_sine": {
          "description": "Sinusoidal ease-in-out. Very smooth, subtle effect.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_sine"
          }
        },
        "in_expo": {
          "description": "Exponential ease-in. Extreme slow start.",
          "returns": {
            "type": "Symbol",
            "description": ":in_expo"
          }
        },
        "out_expo": {
          "description": "Exponential ease-out. Extreme fast start.",
          "returns": {
            "type": "Symbol",
            "description": ":out_expo"
          }
        },
        "in_out_expo": {
          "description": "Exponential ease-in-out.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_expo"
          }
        },
        "in_circ": {
          "description": "Circular ease-in.",
          "returns": {
            "type": "Symbol",
            "description": ":in_circ"
          }
        },
        "out_circ": {
          "description": "Circular ease-out.",
          "returns": {
            "type": "Symbol",
            "description": ":out_circ"
          }
        },
        "in_out_circ": {
          "description": "Circular ease-in-out.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_circ"
          }
        },
        "in_back": {
          "description": "Back ease-in. Pulls back before moving forward.",
          "returns": {
            "type": "Symbol",
            "description": ":in_back"
          }
        },
        "out_back": {
          "description": "Back ease-out. Overshoots target, then settles. Great for UI.",
          "returns": {
            "type": "Symbol",
            "description": ":out_back"
          }
        },
        "in_out_back": {
          "description": "Back ease-in-out. Overshoots on both ends.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_back"
          }
        },
        "in_elastic": {
          "description": "Elastic ease-in. Spring-like wind-up.",
          "returns": {
            "type": "Symbol",
            "description": ":in_elastic"
          }
        },
        "out_elastic": {
          "description": "Elastic ease-out. Spring-like bounce at end. Great for attention.",
          "returns": {
            "type": "Symbol",
            "description": ":out_elastic"
          }
        },
        "in_out_elastic": {
          "description": "Elastic ease-in-out. Spring on both ends.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_elastic"
          }
        },
        "in_bounce": {
          "description": "Bounce ease-in. Bouncing at start.",
          "returns": {
            "type": "Symbol",
            "description": ":in_bounce"
          }
        },
        "out_bounce": {
          "description": "Bounce ease-out. Bouncing at end, like a ball.",
          "returns": {
            "type": "Symbol",
            "description": ":out_bounce"
          }
        },
        "in_out_bounce": {
          "description": "Bounce ease-in-out. Bouncing on both ends.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_bounce"
          }
        },
        "apply": {
          "description": "Apply an easing function to a normalized time value. Useful for custom interpolation outside of tweens.",
          "params": [
            {
              "name": "ease",
              "type": "Symbol",
              "description": "The easing function to apply"
            },
            {
              "name": "t",
              "type": "Float",
              "description": "Normalized time (0.0 to 1.0)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Eased value (usually 0.0 to 1.0, but may overshoot for elastic/back)"
          },
          "example": "# Custom interpolation\n  t = elapsed / duration\n  eased_t = GMR::Ease.apply(:out_back, t)\n  current_x = start_x + (end_x - start_x) * eased_t"
        }
      }
    },
    "GMR::Graphics::Texture": {
      "kind": "class",
      "description": "TODO: Add description",
      "classMethods": {
        "load": {
          "description": "Load a texture from a file. Supports PNG, JPG, BMP, and other common formats.",
          "params": [
            {
              "name": "path",
              "type": "String",
              "description": "Path to the image file (relative to game root)"
            }
          ],
          "returns": {
            "type": "Texture",
            "description": "The loaded texture object"
          },
          "raises": [
            "RuntimeError if the file cannot be loaded"
          ],
          "example": "sprite = GMR::Graphics::Texture.load(\"assets/player.png\")"
        }
      },
      "instanceMethods": {
        "width": {
          "description": "Get the texture width in pixels",
          "returns": {
            "type": "Integer",
            "description": "Width in pixels"
          },
          "example": "puts sprite.width"
        },
        "height": {
          "description": "Get the texture height in pixels",
          "returns": {
            "type": "Integer",
            "description": "Height in pixels"
          },
          "example": "puts sprite.height"
        },
        "draw": {
          "description": "Draw the texture at a position, optionally with a color tint",
          "params": [
            {
              "name": "x",
              "type": "Integer",
              "description": "X position (left edge)"
            },
            {
              "name": "y",
              "type": "Integer",
              "description": "Y position (top edge)"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "(optional, default: [255, 255, 255]) Color tint (multiplied with texture)"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "sprite.draw(100, 100)"
        },
        "draw_ex": {
          "description": "Draw the texture with rotation and scaling",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "X position"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "Y position"
            },
            {
              "name": "rotation",
              "type": "Float",
              "description": "Rotation angle in degrees"
            },
            {
              "name": "scale",
              "type": "Float",
              "description": "Scale multiplier (1.0 = original size)"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "(optional, default: [255, 255, 255]) Color tint"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "sprite.draw_ex(160, 120, 45.0, 2.0)"
        },
        "draw_pro": {
          "description": "A tile-based map for efficient rendering of large worlds using a tileset texture",
          "params": [
            {
              "name": "sx",
              "type": "Float",
              "description": "Source X (top-left of region)"
            },
            {
              "name": "sy",
              "type": "Float",
              "description": "Source Y (top-left of region)"
            },
            {
              "name": "sw",
              "type": "Float",
              "description": "Source width"
            },
            {
              "name": "sh",
              "type": "Float",
              "description": "Source height"
            },
            {
              "name": "dx",
              "type": "Float",
              "description": "Destination X (center)"
            },
            {
              "name": "dy",
              "type": "Float",
              "description": "Destination Y (center)"
            },
            {
              "name": "dw",
              "type": "Float",
              "description": "Destination width"
            },
            {
              "name": "dh",
              "type": "Float",
              "description": "Destination height"
            },
            {
              "name": "rotation",
              "type": "Float",
              "description": "Rotation angle in degrees"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "(optional, default: [255, 255, 255]) Color tint"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "sprite.draw_pro(0, 0, 32, 32, 160, 120, 64, 64, 0)"
        }
      }
    },
    "GMR::Graphics::Tilemap": {
      "kind": "class",
      "description": "TODO: Add description",
      "classMethods": {
        "new": {
          "signature": "new(tileset:, tile_width:, tile_height:, width:, height:)",
          "description": "Create a new tilemap with the specified dimensions. All tiles are initialized to -1 (empty/transparent).",
          "params": [
            {
              "name": "tileset",
              "type": "Texture",
              "description": "The tileset texture containing all tile graphics"
            },
            {
              "name": "tile_width",
              "type": "Integer",
              "description": "Width of each tile in pixels"
            },
            {
              "name": "tile_height",
              "type": "Integer",
              "description": "Height of each tile in pixels"
            },
            {
              "name": "width",
              "type": "Integer",
              "description": "Map width in tiles"
            },
            {
              "name": "height",
              "type": "Integer",
              "description": "Map height in tiles"
            }
          ],
          "returns": {
            "type": "Tilemap",
            "description": "The new tilemap object"
          },
          "raises": [
            "ArgumentError if dimensions are not positive"
          ],
          "example": "tileset = GMR::Graphics::Texture.load(\"assets/tiles.png\")\nmap = GMR::Graphics::Tilemap.new(tileset, 16, 16, 100, 50)"
        }
      },
      "instanceMethods": {
        "tile_width": {
          "signature": "tile_width",
          "description": "TODO: Add documentation",
          "params": [],
          "returns": {
            "type": "unknown"
          }
        },
        "tile_height": {
          "signature": "tile_height",
          "description": "TODO: Add documentation",
          "params": [],
          "returns": {
            "type": "unknown"
          }
        },
        "get": {
          "signature": "get(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "set": {
          "signature": "set(arg1, arg2, arg3)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            },
            {
              "name": "arg3",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "fill": {
          "signature": "fill(arg1)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "fill_rect": {
          "signature": "fill_rect(arg1, arg2, arg3, arg4, arg5)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            },
            {
              "name": "arg3",
              "type": "Integer"
            },
            {
              "name": "arg4",
              "type": "Integer"
            },
            {
              "name": "arg5",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "draw_region": {
          "signature": "draw_region(arg1, arg2, arg3, arg4, arg5, arg6, [arg7])",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            },
            {
              "name": "arg3",
              "type": "Integer"
            },
            {
              "name": "arg4",
              "type": "Integer"
            },
            {
              "name": "arg5",
              "type": "Integer"
            },
            {
              "name": "arg6",
              "type": "Integer"
            },
            {
              "name": "arg7",
              "type": "Array",
              "optional": true
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "define_tile": {
          "signature": "define_tile(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Hash"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "tile_properties": {
          "signature": "tile_properties(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "tile_property": {
          "signature": "tile_property(arg1, arg2, arg3)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            },
            {
              "name": "arg3",
              "type": "Symbol"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "solid?": {
          "signature": "solid?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "wall?": {
          "signature": "wall?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "any"
            },
            {
              "name": "arg2",
              "type": "any"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "hazard?": {
          "signature": "hazard?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "platform?": {
          "signature": "platform?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "ladder?": {
          "signature": "ladder?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "water?": {
          "signature": "water?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "slippery?": {
          "signature": "slippery?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "damage": {
          "signature": "damage(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        }
      }
    },
    "Vec2": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Vec2 with optional x and y values.",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "The x component (default: 0)"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "The y component (default: 0)"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The new vector"
          },
          "example": "Vec2.new(100, 200)    # (100, 200)"
        },
        "x": {
          "description": "Get the x component.",
          "returns": {
            "type": "Float",
            "description": "The x value"
          },
          "example": "x = vec.x"
        },
        "y": {
          "description": "Get the y component.",
          "returns": {
            "type": "Float",
            "description": "The y value"
          },
          "example": "y = vec.y"
        },
        "+": {
          "description": "Add two vectors, returning a new Vec2.",
          "params": [
            {
              "name": "other",
              "type": "Vec2",
              "description": "The vector to add"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "A new vector with the sum"
          },
          "example": "result = Vec2.new(1, 2) + Vec2.new(3, 4)  # Vec2(4, 6)"
        },
        "-": {
          "description": "Subtract two vectors, returning a new Vec2.",
          "params": [
            {
              "name": "other",
              "type": "Vec2",
              "description": "The vector to subtract"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "A new vector with the difference"
          },
          "example": "result = Vec2.new(5, 5) - Vec2.new(2, 1)  # Vec2(3, 4)"
        },
        "*": {
          "description": "Multiply vector by a scalar, returning a new Vec2.",
          "params": [
            {
              "name": "scalar",
              "type": "Float",
              "description": "The scalar value"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "A new scaled vector"
          },
          "example": "result = Vec2.new(2, 3) * 2.0  # Vec2(4, 6)"
        },
        "/": {
          "description": "Divide vector by a scalar, returning a new Vec2.",
          "params": [
            {
              "name": "scalar",
              "type": "Float",
              "description": "The scalar value (must not be zero)"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "A new scaled vector"
          },
          "example": "result = Vec2.new(10, 20) / 2.0  # Vec2(5, 10)"
        },
        "to_s": {
          "description": "A 3D vector with x, y, and z components. Used for 3D positions, colors (RGB), and other 3-component values. Supports arithmetic operations.",
          "returns": {
            "type": "String",
            "description": "String in format \"Vec2(x, y)\""
          },
          "example": "# 3D position for parallax layers\n  class ParallaxLayer\r\n    def initialize(texture, depth)\r"
        }
      }
    },
    "Vec3": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Vec3 with optional x, y, and z values.",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "The x component (default: 0)"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "The y component (default: 0)"
            },
            {
              "name": "z",
              "type": "Float",
              "description": "The z component (default: 0)"
            }
          ],
          "returns": {
            "type": "Vec3",
            "description": "The new vector"
          },
          "example": "Vec3.new(1, 2, 3)     # (1, 2, 3)"
        },
        "x": {
          "description": "Get the x component.",
          "returns": {
            "type": "Float",
            "description": "The x value"
          },
          "example": "x = vec.x"
        },
        "y": {
          "description": "Get the y component.",
          "returns": {
            "type": "Float",
            "description": "The y value"
          },
          "example": "y = vec.y"
        },
        "z": {
          "description": "Get the z component.",
          "returns": {
            "type": "Float",
            "description": "The z value"
          },
          "example": "z = vec.z"
        },
        "+": {
          "description": "Add two vectors, returning a new Vec3.",
          "params": [
            {
              "name": "other",
              "type": "Vec3",
              "description": "The vector to add"
            }
          ],
          "returns": {
            "type": "Vec3",
            "description": "A new vector with the sum"
          },
          "example": "result = Vec3.new(1, 2, 3) + Vec3.new(1, 1, 1)  # Vec3(2, 3, 4)"
        },
        "-": {
          "description": "Subtract two vectors, returning a new Vec3.",
          "params": [
            {
              "name": "other",
              "type": "Vec3",
              "description": "The vector to subtract"
            }
          ],
          "returns": {
            "type": "Vec3",
            "description": "A new vector with the difference"
          },
          "example": "result = Vec3.new(5, 5, 5) - Vec3.new(1, 2, 3)  # Vec3(4, 3, 2)"
        },
        "*": {
          "description": "Multiply vector by a scalar, returning a new Vec3.",
          "params": [
            {
              "name": "scalar",
              "type": "Float",
              "description": "The scalar value"
            }
          ],
          "returns": {
            "type": "Vec3",
            "description": "A new scaled vector"
          },
          "example": "result = Vec3.new(1, 2, 3) * 2.0  # Vec3(2, 4, 6)"
        },
        "/": {
          "description": "Divide vector by a scalar, returning a new Vec3.",
          "params": [
            {
              "name": "scalar",
              "type": "Float",
              "description": "The scalar value (must not be zero)"
            }
          ],
          "returns": {
            "type": "Vec3",
            "description": "A new scaled vector"
          },
          "example": "result = Vec3.new(10, 20, 30) / 10.0  # Vec3(1, 2, 3)"
        },
        "to_s": {
          "description": "A rectangle with position (x, y) and dimensions (w, h). Used for bounds, source rectangles, collision areas, and UI layout.",
          "returns": {
            "type": "String",
            "description": "String in format \"Vec3(x, y, z)\""
          },
          "example": "# UI layout helper\n  class UILayoutHelper\r\n    def initialize(container)\r"
        }
      }
    },
    "Rect": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Rect with optional position and dimensions.",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "The x position (default: 0)"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "The y position (default: 0)"
            },
            {
              "name": "w",
              "type": "Float",
              "description": "The width (default: 0)"
            },
            {
              "name": "h",
              "type": "Float",
              "description": "The height (default: 0)"
            }
          ],
          "returns": {
            "type": "Rect",
            "description": "The new rectangle"
          },
          "example": "Rect.new(10, 20, 100, 50)   # x=10, y=20, w=100, h=50"
        },
        "x": {
          "description": "Get the x position (left edge).",
          "returns": {
            "type": "Float",
            "description": "The x position"
          },
          "example": "x = rect.x"
        },
        "y": {
          "description": "Get the y position (top edge).",
          "returns": {
            "type": "Float",
            "description": "The y position"
          },
          "example": "y = rect.y"
        },
        "w": {
          "description": "Get the width.",
          "returns": {
            "type": "Float",
            "description": "The width"
          },
          "example": "width = rect.w"
        },
        "h": {
          "description": "Get the height.",
          "returns": {
            "type": "Float",
            "description": "The height"
          },
          "example": "height = rect.h"
        },
        "to_s": {
          "description": "Convert to a string representation.",
          "returns": {
            "type": "String",
            "description": "String in format \"Rect(x, y, w, h)\""
          },
          "example": "puts Rect.new(0, 0, 32, 32).to_s  # \"Rect(0.00, 0.00, 32.00, 32.00)\""
        }
      }
    },
    "Node": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Node with default transform.",
          "returns": {
            "type": "Node",
            "description": "The new node"
          },
          "example": "node = Node.new"
        },
        "add_child": {
          "description": "Add a child node. Removes from previous parent if any. Cycle detection prevents a node from becoming its own ancestor.",
          "params": [
            {
              "name": "child",
              "type": "Node",
              "description": "The node to add as a child"
            }
          ],
          "returns": {
            "type": "Node",
            "description": "self for chaining"
          },
          "example": "root.add_child(child)"
        },
        "remove_child": {
          "description": "Remove a child node. The child becomes a root node.",
          "params": [
            {
              "name": "child",
              "type": "Node",
              "description": "The node to remove"
            }
          ],
          "returns": {
            "type": "Node",
            "description": "self for chaining"
          },
          "example": "root.remove_child(child)"
        },
        "parent": {
          "description": "Get the parent node, or nil if this is a root.",
          "returns": {
            "type": "Node, nil",
            "description": "The parent node"
          },
          "example": "if node.parent then puts \"has parent\" end"
        },
        "children": {
          "description": "Get an array of child nodes.",
          "returns": {
            "type": "Array<Node>",
            "description": "Array of children (empty if none)"
          },
          "example": "node.children.each { |c| puts c.local_position }"
        },
        "child_count": {
          "description": "Get the number of children.",
          "returns": {
            "type": "Integer",
            "description": "Number of children"
          },
          "example": "puts node.child_count"
        },
        "local_position": {
          "description": "Get the local position relative to parent.",
          "returns": {
            "type": "Vec2",
            "description": "The local position"
          },
          "example": "pos = node.local_position"
        },
        "local_rotation": {
          "description": "Get the local rotation in degrees.",
          "returns": {
            "type": "Float",
            "description": "The local rotation"
          },
          "example": "angle = node.local_rotation"
        },
        "local_scale": {
          "description": "Get the local scale.",
          "returns": {
            "type": "Vec2",
            "description": "The local scale"
          },
          "example": "scale = node.local_scale"
        },
        "local_position=": {
          "description": "Set the local position relative to parent.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The new local position"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "node.local_position = Vec2.new(100, 50)"
        },
        "local_rotation=": {
          "description": "Set the local rotation in degrees.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new local rotation"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "node.local_rotation = 45"
        },
        "local_scale=": {
          "description": "Set the local scale.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The new local scale"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "node.local_scale = Vec2.new(2, 2)"
        },
        "world_position": {
          "description": "Get the world position after hierarchy composition. Call Node.update_world_transforms(root) first to ensure accuracy.",
          "returns": {
            "type": "Vec2",
            "description": "The world position"
          },
          "example": "pos = child.world_position"
        },
        "world_rotation": {
          "description": "Get the world rotation in degrees after hierarchy composition.",
          "returns": {
            "type": "Float",
            "description": "The world rotation"
          },
          "example": "angle = child.world_rotation"
        },
        "world_scale": {
          "description": "Get the world scale after hierarchy composition.",
          "returns": {
            "type": "Vec2",
            "description": "The world scale"
          },
          "example": "scale = child.world_scale"
        },
        "active": {
          "description": "Get the active flag of this node (ignores parent state).",
          "returns": {
            "type": "Boolean",
            "description": "true if this node is active"
          },
          "example": "if node.active then ... end"
        },
        "active=": {
          "description": "Set the active flag of this node.",
          "params": [
            {
              "name": "value",
              "type": "Boolean",
              "description": "true to activate, false to deactivate"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "The value that was set"
          },
          "example": "node.active = false"
        },
        "active?": {
          "description": "Check if this node is active in the full hierarchy. Returns false if this node or any ancestor is inactive.",
          "returns": {
            "type": "Boolean",
            "description": "true if active in hierarchy"
          },
          "example": "if node.active? then update(node) end"
        },
        "Node.update_world_transforms": {
          "description": "Update world transforms for a node and all descendants. Call this on the root before reading world_position/rotation/scale.",
          "params": [
            {
              "name": "root",
              "type": "Node",
              "description": "The root node to start from"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "Node.update_world_transforms(root)"
        }
      }
    },
    "GMR::Scene": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "init": {
          "description": "Called once when the scene becomes active. Override to initialize scene state."
        },
        "update": {
          "description": "Called every frame while this scene is on top of the stack. Override to update game logic.",
          "params": [
            {
              "name": "dt",
              "type": "Float",
              "description": "Delta time in seconds since last frame"
            }
          ]
        },
        "draw": {
          "description": "Called every frame while this scene is on top of the stack. Override to draw scene content."
        },
        "unload": {
          "description": "Stack-based scene lifecycle manager. Use load to switch scenes (clears stack), push to add a scene on top, and pop to return to the previous scene."
        }
      }
    },
    "GMR::SceneManager": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "load": {
          "description": "Clear the scene stack and load a new scene. Calls unload on all existing scenes (top to bottom), then init on the new scene.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The scene to load"
            }
          ],
          "example": "GMR::SceneManager.load(TitleScene.new)"
        },
        "register": {
          "description": "Alias for load. Clear the scene stack and load a new scene.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The scene to load"
            }
          ],
          "example": "GMR::SceneManager.register(TitleScene.new)"
        },
        "push": {
          "description": "Push a new scene onto the stack. The current scene is paused (no longer receives update/draw). Calls init on the new scene.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The scene to push"
            }
          ],
          "example": "GMR::SceneManager.push(PauseScene.new)"
        },
        "pop": {
          "description": "Remove the top scene from the stack. Calls unload on the removed scene. The previous scene resumes receiving update/draw calls.",
          "example": "GMR::SceneManager.pop"
        },
        "update": {
          "description": "Call update on the top scene. Call this from your game's update function.",
          "params": [
            {
              "name": "dt",
              "type": "Float",
              "description": "Delta time in seconds"
            }
          ],
          "example": "def update(dt)\n  GMR::SceneManager.update(dt)\r\nend\r"
        },
        "draw": {
          "description": "Call draw on the top scene. Call this from your game's draw function.",
          "example": "def draw\n  GMR::SceneManager.draw\r\nend\r"
        },
        "add_overlay": {
          "description": "Add an overlay scene that renders on top of the main scene. Overlays receive update and draw calls. Multiple overlays can be active.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The overlay scene to add"
            }
          ],
          "example": "GMR::SceneManager.add_overlay(MinimapOverlay.new)"
        },
        "remove_overlay": {
          "description": "Remove an overlay scene.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The overlay scene to remove"
            }
          ],
          "example": "GMR::SceneManager.remove_overlay(@minimap)"
        },
        "has_overlay?": {
          "description": "Check if an overlay is currently active.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The overlay scene to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the overlay is active"
          },
          "example": "if GMR::SceneManager.has_overlay?(@minimap)"
        }
      }
    },
    "Sprite": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Sprite from a texture with optional initial values.",
          "params": [
            {
              "name": "texture",
              "type": "Texture",
              "description": "The texture to use for this sprite"
            },
            {
              "name": "x",
              "type": "Float",
              "description": "Initial X position (default: 0)"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "Initial Y position (default: 0)"
            },
            {
              "name": "rotation",
              "type": "Float",
              "description": "Initial rotation in degrees (default: 0)"
            },
            {
              "name": "scale_x",
              "type": "Float",
              "description": "Initial X scale (default: 1.0)"
            },
            {
              "name": "scale_y",
              "type": "Float",
              "description": "Initial Y scale (default: 1.0)"
            },
            {
              "name": "z",
              "type": "Float",
              "description": "Explicit z-index for layering (default: nil, uses draw order)"
            },
            {
              "name": "source_rect",
              "type": "Rect",
              "description": "Region of texture to draw (default: entire texture)"
            }
          ],
          "returns": {
            "type": "Sprite",
            "description": "The new sprite"
          },
          "example": "sprite = Sprite.new(spritesheet, source_rect: Rect.new(0, 0, 32, 32))"
        },
        "x": {
          "description": "Get the X position of the sprite.",
          "returns": {
            "type": "Float",
            "description": "The X position"
          },
          "example": "x_pos = sprite.x"
        },
        "y": {
          "description": "Get the Y position of the sprite.",
          "returns": {
            "type": "Float",
            "description": "The Y position"
          },
          "example": "y_pos = sprite.y"
        },
        "x=": {
          "description": "Set the X position of the sprite.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new X position"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "sprite.x += 5  # Move right by 5 pixels"
        },
        "y=": {
          "description": "Set the Y position of the sprite.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new Y position"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "sprite.y += 10  # Move down by 10 pixels"
        },
        "position": {
          "description": "Get the position as a Vec2.",
          "returns": {
            "type": "Vec2",
            "description": "The position vector"
          },
          "example": "pos = sprite.position"
        },
        "position=": {
          "description": "Set the position using a Vec2.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The new position vector"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "sprite.position = Vec2.new(100, 200)"
        },
        "rotation": {
          "description": "Get the rotation in degrees.",
          "returns": {
            "type": "Float",
            "description": "The rotation angle in degrees"
          },
          "example": "angle = sprite.rotation"
        },
        "rotation=": {
          "description": "Set the rotation in degrees. Positive values rotate clockwise.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new rotation angle in degrees"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "sprite.rotation += 90 * dt  # Rotate 90 degrees per second"
        },
        "scale_x": {
          "description": "Get the X scale factor.",
          "returns": {
            "type": "Float",
            "description": "The X scale (1.0 = normal size)"
          },
          "example": "sx = sprite.scale_x"
        },
        "scale_y": {
          "description": "Get the Y scale factor.",
          "returns": {
            "type": "Float",
            "description": "The Y scale (1.0 = normal size)"
          },
          "example": "sy = sprite.scale_y"
        },
        "scale_x=": {
          "description": "Set the X scale factor. Values greater than 1 stretch, less than 1 shrink.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new X scale (1.0 = normal size)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "sprite.scale_x = 2.0  # Double width"
        },
        "scale_y=": {
          "description": "Set the Y scale factor. Values greater than 1 stretch, less than 1 shrink.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new Y scale (1.0 = normal size)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "sprite.scale_y = 0.5  # Half height"
        },
        "origin_x": {
          "description": "Get the X origin (pivot point) for rotation and scaling.",
          "returns": {
            "type": "Float",
            "description": "The X origin offset in pixels"
          },
          "example": "ox = sprite.origin_x"
        },
        "origin_y": {
          "description": "Get the Y origin (pivot point) for rotation and scaling.",
          "returns": {
            "type": "Float",
            "description": "The Y origin offset in pixels"
          },
          "example": "oy = sprite.origin_y"
        },
        "origin_x=": {
          "description": "Set the X origin (pivot point) for rotation and scaling.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The X origin offset in pixels"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "sprite.origin_x = 16  # Pivot 16px from left"
        },
        "origin_y=": {
          "description": "Set the Y origin (pivot point) for rotation and scaling.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The Y origin offset in pixels"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "sprite.origin_y = 16  # Pivot 16px from top"
        },
        "origin": {
          "description": "Get the origin (pivot point) as a Vec2.",
          "returns": {
            "type": "Vec2",
            "description": "The origin vector"
          },
          "example": "origin = sprite.origin"
        },
        "origin=": {
          "description": "Set the origin (pivot point) using a Vec2.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The new origin vector"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "sprite.origin = Vec2.new(16, 16)"
        },
        "center_origin": {
          "description": "Set the origin to the center of the sprite, so it rotates and scales around its center. Uses texture dimensions or source_rect if set.",
          "returns": {
            "type": "Sprite",
            "description": "self for chaining"
          },
          "example": "sprite = Sprite.new(tex).center_origin  # Method chaining"
        },
        "z": {
          "description": "Get the explicit z-index for layering. Returns nil if using automatic draw order (the default). Higher z values render on top of lower values.",
          "returns": {
            "type": "Float, nil",
            "description": "The z-index, or nil if using draw order"
          },
          "example": "if sprite.z.nil?\n  puts \"Using automatic draw order\"\r\nend\r"
        },
        "z=": {
          "description": "Set an explicit z-index for layering, or nil to use draw order. By default (nil), sprites are layered by draw order - later drawn sprites appear on top. Setting an explicit z gives you precise control over layering.",
          "params": [
            {
              "name": "value",
              "type": "Float, nil",
              "description": "The z-index (higher = on top), or nil for draw order"
            }
          ],
          "returns": {
            "type": "Float, nil",
            "description": "The value that was set"
          },
          "example": "# Typical usage pattern"
        },
        "color": {
          "description": "Get the color tint as an RGBA array. White [255,255,255,255] means no tint.",
          "returns": {
            "type": "Array<Integer>",
            "description": "RGBA color array [r, g, b, a]"
          },
          "example": "r, g, b, a = sprite.color"
        },
        "color=": {
          "description": "Set the color tint as an RGBA array. The sprite is multiplied by this color.",
          "params": [
            {
              "name": "value",
              "type": "Array<Integer>",
              "description": "RGBA color array [r, g, b] or [r, g, b, a]"
            }
          ],
          "returns": {
            "type": "Array<Integer>",
            "description": "The value that was set"
          },
          "example": "sprite.color = [255, 255, 255, 128]  # 50% transparent"
        },
        "alpha": {
          "description": "Get the alpha (opacity) as a float from 0.0 (invisible) to 1.0 (opaque).",
          "returns": {
            "type": "Float",
            "description": "The alpha value"
          },
          "example": "a = sprite.alpha"
        },
        "alpha=": {
          "description": "Set the alpha (opacity) from 0.0 (invisible) to 1.0 (opaque).",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new alpha value (0.0 to 1.0)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "sprite.alpha = 0    # Invisible"
        },
        "flip_x": {
          "description": "Check if the sprite is flipped horizontally.",
          "returns": {
            "type": "Boolean",
            "description": "true if flipped horizontally"
          },
          "example": "if sprite.flip_x\n  puts \"Facing left\"\r\nend\r"
        },
        "flip_y": {
          "description": "Check if the sprite is flipped vertically.",
          "returns": {
            "type": "Boolean",
            "description": "true if flipped vertically"
          },
          "example": "if sprite.flip_y\n  puts \"Flipped upside down\"\r\nend\r"
        },
        "flip_x=": {
          "description": "Set whether the sprite is flipped horizontally. Useful for facing direction.",
          "params": [
            {
              "name": "value",
              "type": "Boolean",
              "description": "true to flip horizontally"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "The value that was set"
          },
          "example": "sprite.flip_x = velocity.x < 0  # Face movement direction"
        },
        "flip_y=": {
          "description": "Set whether the sprite is flipped vertically.",
          "params": [
            {
              "name": "value",
              "type": "Boolean",
              "description": "true to flip vertically"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "The value that was set"
          },
          "example": "sprite.flip_y = true"
        },
        "texture": {
          "description": "Get the current texture.",
          "returns": {
            "type": "Texture",
            "description": "The sprite's texture"
          },
          "example": "tex = sprite.texture"
        },
        "texture=": {
          "description": "Set the texture to draw.",
          "params": [
            {
              "name": "value",
              "type": "Texture",
              "description": "The new texture"
            }
          ],
          "returns": {
            "type": "Texture",
            "description": "The value that was set"
          },
          "example": "sprite.texture = new_texture"
        },
        "source_rect": {
          "description": "Get the source rectangle (region of texture to draw). Returns nil if using the entire texture.",
          "returns": {
            "type": "Rect, nil",
            "description": "The source rectangle, or nil if using full texture"
          },
          "example": "rect = sprite.source_rect"
        },
        "source_rect=": {
          "description": "Set the source rectangle to draw only part of the texture. Useful for sprite sheets and animations. Set to nil to draw the full texture.",
          "params": [
            {
              "name": "value",
              "type": "Rect, nil",
              "description": "The source rectangle, or nil for full texture"
            }
          ],
          "returns": {
            "type": "Rect, nil",
            "description": "The value that was set"
          },
          "example": "@sprite.source_rect = nil  # Use full texture"
        },
        "width": {
          "description": "Get the width of the sprite (from source_rect or texture).",
          "returns": {
            "type": "Integer",
            "description": "The width in pixels"
          },
          "example": "w = sprite.width"
        },
        "height": {
          "description": "Get the height of the sprite (from source_rect or texture).",
          "returns": {
            "type": "Integer",
            "description": "The height in pixels"
          },
          "example": "h = sprite.height"
        },
        "parent": {
          "description": "Get the parent Transform2D. Returns nil if no parent is set.",
          "returns": {
            "type": "Transform2D, nil",
            "description": "The parent transform, or nil if none"
          },
          "example": "parent = sprite.parent"
        },
        "parent=": {
          "description": "Set a Transform2D as the parent. The sprite will transform relative to the parent's world transform. Set to nil to remove the parent.",
          "params": [
            {
              "name": "value",
              "type": "Transform2D, nil",
              "description": "The parent transform, or nil to clear"
            }
          ],
          "returns": {
            "type": "Transform2D, nil",
            "description": "The value that was set"
          },
          "example": "# Sprite follows a transform\n  turret_base = Transform2D.new(x: 200, y: 200)\r"
        },
        "draw": {
          "description": "Queue the sprite for rendering. Sprites are drawn in z-order after all draw() calls complete. By default, draw order determines layering (later = on top). Set sprite.z to override with an explicit z-index.",
          "returns": {
            "type": "Sprite",
            "description": "self for chaining"
          },
          "example": "# Method chaining"
        },
        "count": {
          "description": "Get the total number of active sprites (class method).",
          "returns": {
            "type": "Integer",
            "description": "The number of active sprites"
          },
          "example": "puts \"Active sprites: #{Sprite.count}\""
        },
        "play_animation": {
          "description": "Convenience method to create and play a sprite animation. Creates a GMR::SpriteAnimation, calls play, and returns it for chaining.",
          "returns": {
            "type": "SpriteAnimation",
            "description": "The animation instance (already playing)"
          },
          "example": "sprite.play_animation(frames: [0, 1, 2, 3], fps: 12)"
        }
      }
    },
    "GMR::SpriteAnimation": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new sprite animation.",
          "params": [
            {
              "name": "sprite",
              "type": "Sprite",
              "description": "The sprite to animate"
            }
          ],
          "example": "# Attack combo with non-looping animation"
        },
        "play": {
          "description": "Start or resume the animation.",
          "returns": {
            "type": "SpriteAnimation",
            "description": "self for chaining"
          },
          "example": "# State machine integration - play animation when entering run state\n  state :run do\n    enter { @animations[:run].play }\n    exit { @animations[:run].stop }\n    on :stop, :idle\n    on :jump, :jumping\n  end"
        },
        "pause": {
          "description": "Pause the animation at the current frame.",
          "returns": {
            "type": "SpriteAnimation",
            "description": "self for chaining"
          },
          "example": "anim.pause"
        },
        "stop": {
          "description": "Stop the animation and reset to the first frame.",
          "returns": {
            "type": "SpriteAnimation",
            "description": "self for chaining"
          },
          "example": "anim.stop"
        },
        "on_complete": {
          "description": "Set a callback for when the animation finishes (non-looping only).",
          "returns": {
            "type": "SpriteAnimation",
            "description": "self for chaining"
          },
          "example": "# Chain attack animation into recovery state\n  def start_attack"
        },
        "on_frame_change": {
          "description": "Set a callback for each frame change. Receives frame index.",
          "returns": {
            "type": "SpriteAnimation",
            "description": "self for chaining"
          },
          "example": "# Spawn attack hitbox on specific frame"
        },
        "playing?": {
          "description": "Check if the animation is currently playing.",
          "returns": {
            "type": "Boolean",
            "description": "true if playing"
          }
        },
        "complete?": {
          "description": "Check if the animation has completed (non-looping only).",
          "returns": {
            "type": "Boolean",
            "description": "true if completed"
          }
        },
        "frame": {
          "description": "Get the current frame index (from the frames array).",
          "returns": {
            "type": "Integer",
            "description": "Current frame index"
          }
        },
        "frame=": {
          "description": "Set the current frame index directly.",
          "params": [
            {
              "name": "index",
              "type": "Integer",
              "description": "Frame index (into frames array)"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "The frame index"
          }
        },
        "fps": {
          "description": "Get the frames per second.",
          "returns": {
            "type": "Float",
            "description": "FPS"
          }
        },
        "fps=": {
          "description": "Set the frames per second.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "New FPS"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The FPS value"
          },
          "example": "# Speed up animation when player is running fast\n  def update(dt)\n    speed = calculate_movement_speed\n    # Scale animation FPS with movement speed (8-16 fps range)"
        },
        "loop?": {
          "description": "Check if the animation loops.",
          "returns": {
            "type": "Boolean",
            "description": "true if looping"
          }
        },
        "loop=": {
          "description": "Set whether the animation loops.",
          "params": [
            {
              "name": "value",
              "type": "Boolean",
              "description": "true to loop"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "The loop value"
          }
        },
        "count": {
          "description": "Get the number of active sprite animations.",
          "returns": {
            "type": "Integer",
            "description": "Number of active animations"
          }
        }
      }
    },
    "GMR::StateMachine": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "attach": {
          "description": "Attach a state machine to an object. Called internally by Object#state_machine.",
          "params": [
            {
              "name": "owner",
              "type": "Object",
              "description": "The object to attach the state machine to"
            }
          ],
          "returns": {
            "type": "StateMachine",
            "description": "The created state machine"
          }
        },
        "count": {
          "description": "Get the number of active state machines.",
          "returns": {
            "type": "Integer",
            "description": "Number of active machines"
          }
        },
        "trigger": {
          "description": "Trigger an event, causing a transition if one is defined.",
          "params": [
            {
              "name": "event",
              "type": "Symbol",
              "description": "The event to trigger"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if a transition occurred"
          },
          "example": "# Chain triggers from animation callbacks"
        },
        "state": {
          "description": "Define a state with its behavior.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The state name"
            }
          ]
        },
        "state=": {
          "description": "Force a state change, bypassing transitions.",
          "params": [
            {
              "name": "new_state",
              "type": "Symbol",
              "description": "The state to switch to"
            }
          ],
          "returns": {
            "type": "Symbol",
            "description": "The new state"
          }
        },
        "active?": {
          "description": "Check if the state machine is active.",
          "returns": {
            "type": "Boolean",
            "description": "true if active"
          }
        },
        "animate": {
          "description": "Set the animation to play when entering this state.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The animation name (looked up in @animations hash)"
            }
          ]
        },
        "on": {
          "description": "Define a transition from this state.",
          "params": [
            {
              "name": "event",
              "type": "Symbol",
              "description": "The event that triggers the transition"
            },
            {
              "name": "target",
              "type": "Symbol",
              "description": "The target state"
            }
          ],
          "example": "# Multiple transitions from same state\n  state :grounded do\r\n    on :jump, :jumping\r\n    on :crouch, :crouching\r\n    on :damage, :hurt\r\n    on :fall, :falling\r\n  end\r"
        },
        "enter": {
          "description": "Set a callback to run when entering this state.",
          "example": "# Initialize state-specific data on enter\n  state :charging do\r\n    enter do\r"
        },
        "exit": {
          "description": "Set a callback to run when exiting this state.",
          "example": "# Cancel pending actions on state exit\n  state :aiming do\r\n    exit do\r"
        },
        "on_input": {
          "description": "Define an input-driven transition from this state.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The input action that triggers the transition"
            },
            {
              "name": "target",
              "type": "Symbol",
              "description": "The target state"
            }
          ],
          "example": "\n  state :idle do\r\n    on_input :jump, :air\r\n    on_input :attack, :attack, when: :pressed, if: -> { @stamina > 0 }\r\n  end\r\nBuilder#method_missing - Verb-style input transition\r\nUsage: jump :air\r\n       attack.hold :charge\r\n       die! :dead\r\nBuilder#respond_to_missing? - For Ruby introspection\r"
        },
        "state_machine": {
          "description": "Define or get the state machine for this object.",
          "returns": {
            "type": "StateMachine",
            "description": "The state machine"
          }
        }
      }
    },
    "Transform2D": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Transform2D with optional initial values.",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "Initial X position (default: 0)"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "Initial Y position (default: 0)"
            },
            {
              "name": "rotation",
              "type": "Float",
              "description": "Initial rotation in degrees (default: 0)"
            },
            {
              "name": "scale_x",
              "type": "Float",
              "description": "Initial X scale (default: 1.0)"
            },
            {
              "name": "scale_y",
              "type": "Float",
              "description": "Initial Y scale (default: 1.0)"
            },
            {
              "name": "origin_x",
              "type": "Float",
              "description": "Pivot point X (default: 0)"
            },
            {
              "name": "origin_y",
              "type": "Float",
              "description": "Pivot point Y (default: 0)"
            }
          ],
          "returns": {
            "type": "Transform2D",
            "description": "The new transform"
          },
          "example": "t = Transform2D.new(x: 100, y: 50, rotation: 45)"
        },
        "x": {
          "description": "Get the X position of the transform.",
          "returns": {
            "type": "Float",
            "description": "The X position"
          },
          "example": "x_pos = transform.x"
        },
        "y": {
          "description": "Get the Y position of the transform.",
          "returns": {
            "type": "Float",
            "description": "The Y position"
          },
          "example": "y_pos = transform.y"
        },
        "position": {
          "description": "Get the position as a Vec2.",
          "returns": {
            "type": "Vec2",
            "description": "The position vector"
          },
          "example": "pos = transform.position"
        },
        "rotation": {
          "description": "Get the rotation in degrees.",
          "returns": {
            "type": "Float",
            "description": "The rotation angle in degrees"
          },
          "example": "angle = transform.rotation"
        },
        "scale_x": {
          "description": "Get the X scale factor.",
          "returns": {
            "type": "Float",
            "description": "The X scale (1.0 = normal size)"
          },
          "example": "sx = transform.scale_x"
        },
        "scale_y": {
          "description": "Get the Y scale factor.",
          "returns": {
            "type": "Float",
            "description": "The Y scale (1.0 = normal size)"
          },
          "example": "sy = transform.scale_y"
        },
        "origin_x": {
          "description": "Get the X origin (pivot point) for rotation and scaling.",
          "returns": {
            "type": "Float",
            "description": "The X origin offset in pixels"
          },
          "example": "ox = transform.origin_x"
        },
        "origin_y": {
          "description": "Get the Y origin (pivot point) for rotation and scaling.",
          "returns": {
            "type": "Float",
            "description": "The Y origin offset in pixels"
          },
          "example": "oy = transform.origin_y"
        },
        "x=": {
          "description": "Set the X position of the transform.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new X position"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.x += 5  # Move right by 5 pixels"
        },
        "y=": {
          "description": "Set the Y position of the transform.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new Y position"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.y += 10  # Move down by 10 pixels"
        },
        "position=": {
          "description": "Set the position using a Vec2.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The new position vector"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "transform.position = player.position  # Copy another position"
        },
        "rotation=": {
          "description": "Set the rotation in degrees. Positive values rotate clockwise.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new rotation angle in degrees"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.rotation += 90 * dt  # Rotate 90 degrees per second"
        },
        "scale_x=": {
          "description": "Set the X scale factor. Values greater than 1 stretch horizontally, less than 1 shrink. Negative values flip horizontally.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new X scale (1.0 = normal size)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.scale_x = -1.0  # Flip horizontally"
        },
        "scale_y=": {
          "description": "Set the Y scale factor. Values greater than 1 stretch vertically, less than 1 shrink. Negative values flip vertically.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new Y scale (1.0 = normal size)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.scale_y = -1.0  # Flip vertically"
        },
        "origin_x=": {
          "description": "Set the X origin (pivot point) for rotation and scaling. The origin is the point around which the transform rotates and scales.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The X origin offset in pixels from top-left"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.origin_x = 16  # Pivot 16px from left edge"
        },
        "origin_y=": {
          "description": "Set the Y origin (pivot point) for rotation and scaling. The origin is the point around which the transform rotates and scales.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The Y origin offset in pixels from top-left"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.origin_y = 16  # Pivot 16px from top edge"
        },
        "parent": {
          "description": "Get the parent transform. Returns nil if no parent is set. When a transform has a parent, its position, rotation, and scale are relative to the parent's world transform.",
          "returns": {
            "type": "Transform2D, nil",
            "description": "The parent transform, or nil if none"
          },
          "example": "if transform.parent\n  puts \"Has a parent!\"\r\nend\r"
        },
        "parent=": {
          "description": "Set the parent transform for hierarchical transformations. When parented, this transform's position, rotation, and scale become relative to the parent. Set to nil to remove the parent.",
          "params": [
            {
              "name": "value",
              "type": "Transform2D, nil",
              "description": "The parent transform, or nil to clear"
            }
          ],
          "returns": {
            "type": "Transform2D, nil",
            "description": "The value that was set"
          },
          "example": "transform.parent = nil  # Remove parent"
        },
        "world_position": {
          "description": "Get the final world position after applying all parent transforms. For transforms without a parent, this equals the local position. For parented transforms, this returns the actual screen position after parent transformations.",
          "returns": {
            "type": "Vec2",
            "description": "The world position after parent hierarchy composition"
          },
          "example": "# Get world position of a child transform\n  parent = Transform2D.new(x: 100, y: 100)\r\n  parent.rotation = 90\r\n  child = Transform2D.new(x: 50, y: 0)\r\n  child.parent = parent\r\n  pos = child.world_position  # Position after rotation by parent\r"
        }
      }
    },
    "GMR::Tween": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "to": {
          "signature": "from(target, property, start_value, duration:, delay:, ease:)",
          "description": "Create a tween that animates a property TO a target value. The tween starts from the property's current value.",
          "params": [
            {
              "name": "target",
              "type": "Object",
              "description": "The object to animate (must have property getter and setter)"
            },
            {
              "name": "property",
              "type": "Symbol",
              "description": "The property to animate (:x, :y, :alpha, :rotation, etc.)"
            },
            {
              "name": "end_value",
              "type": "Float",
              "description": "The target value to animate to"
            }
          ],
          "returns": {
            "type": "Tween",
            "description": "The tween instance for chaining"
          },
          "example": "# Smooth camera zoom for scope/aim mode\n  def toggle_aim_mode"
        },
        "from": {
          "description": "Create a tween that animates a property FROM a start value to current. Useful for \"animate in\" effects like fading in from transparent.",
          "params": [
            {
              "name": "target",
              "type": "Object",
              "description": "The object to animate"
            },
            {
              "name": "property",
              "type": "Symbol",
              "description": "The property to animate"
            },
            {
              "name": "start_value",
              "type": "Float",
              "description": "The value to animate from"
            }
          ],
          "returns": {
            "type": "Tween",
            "description": "The tween instance for chaining"
          },
          "example": "# Toast notification slides in from bottom\n  class Toast\n    def show(message)"
        },
        "on_complete": {
          "description": "Set a callback to invoke when the tween completes.",
          "returns": {
            "type": "Tween",
            "description": "self for chaining"
          },
          "example": "# Sequence of tweens using on_complete for chaining\n  class Chest\n    def open\n      # First: lid opens\n      GMR::Tween.to(@lid, :rotation, -1.5, duration: 0.3, ease: :out_quad)\n        .on_complete do\n          # Second: spawn item and make it rise"
        },
        "on_update": {
          "description": "Set a callback to invoke each frame during the tween. The callback receives (t, value) where t is normalized progress [0-1] and value is the current interpolated value.",
          "returns": {
            "type": "Tween",
            "description": "self for chaining"
          },
          "example": "# Color cycling effect on update\n  def start_rainbow_effect"
        },
        "cancel": {
          "description": "Cancel the tween immediately. Does not invoke on_complete.",
          "returns": {
            "type": "nil"
          },
          "example": "# Cancel movement when player hits wall\n  class Player\n    def move_to(target_x, target_y)"
        },
        "pause": {
          "description": "Pause the tween. Use resume to continue.",
          "returns": {
            "type": "Tween",
            "description": "self for chaining"
          },
          "example": "# Pause all UI animations when game pauses\n  class PauseMenu\n    def show"
        },
        "resume": {
          "description": "Resume a paused tween.",
          "returns": {
            "type": "Tween",
            "description": "self for chaining"
          },
          "example": "tween.resume"
        },
        "complete?": {
          "description": "Check if the tween has finished.",
          "returns": {
            "type": "Boolean",
            "description": "true if completed"
          },
          "example": "if tween.complete?\n  puts \"Done!\"\nend"
        },
        "active?": {
          "description": "Check if the tween is currently running (not paused, cancelled, or complete).",
          "returns": {
            "type": "Boolean",
            "description": "true if active"
          },
          "example": "if tween.active?\n  puts \"Still animating...\"\nend"
        },
        "paused?": {
          "description": "Check if the tween is paused.",
          "returns": {
            "type": "Boolean",
            "description": "true if paused"
          }
        },
        "progress": {
          "description": "Get the current progress of the tween (0.0 to 1.0).",
          "returns": {
            "type": "Float",
            "description": "Progress value"
          }
        },
        "cancel_all": {
          "description": "Cancel all active tweens.",
          "returns": {
            "type": "nil"
          },
          "example": "# Clean slate when transitioning scenes\n  class GameScene < GMR::Scene\n    def unload\n      # Cancel all tweens to prevent callbacks on destroyed objects\n      GMR::Tween.cancel_all\n      # Clean up resources"
        },
        "count": {
          "description": "Get the number of active tweens.",
          "returns": {
            "type": "Integer",
            "description": "Number of active tweens"
          },
          "example": "puts \"Active tweens: #{GMR::Tween.count}\""
        }
      }
    },
    "GMR": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "inspect": {
          "signature": "inspect",
          "description": "TODO: Add documentation",
          "params": [],
          "returns": {
            "type": "unknown"
          }
        }
      }
    }
  },
  "globals": {
    "lifecycle": {},
    "helpers": {}
  }
}
