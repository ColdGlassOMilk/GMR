{
  "meta": {
    "version": "1.0.0",
    "engine": "GMR",
    "mrubyVersion": "3.4.0",
    "raylibVersion": "5.6-dev"
  },
  "types": {
    "Color": {
      "kind": "alias",
      "type": "Array<Integer>",
      "description": "RGBA color as [r, g, b] or [r, g, b, a], values 0-255. Alpha defaults to 255 if omitted.",
      "examples": [
        "[255, 0, 0]",
        "[255, 0, 0, 128]"
      ]
    },
    "KeyCode": {
      "kind": "union",
      "types": [
        "Integer",
        "Symbol",
        "Array<Integer|Symbol>"
      ],
      "description": "Key identifier - integer constant (KEY_*), symbol (:space, :a, :left, etc.), or array of keys to check any match",
      "symbols": [
        "space",
        "escape",
        "enter",
        "return",
        "tab",
        "backspace",
        "delete",
        "insert",
        "up",
        "down",
        "left",
        "right",
        "home",
        "end",
        "page_up",
        "page_down",
        "left_shift",
        "right_shift",
        "left_control",
        "right_control",
        "left_alt",
        "right_alt",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "f10",
        "f11",
        "f12",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9"
      ]
    },
    "MouseButton": {
      "kind": "union",
      "types": [
        "Integer",
        "Symbol"
      ],
      "description": "Mouse button identifier - integer constant (MOUSE_*) or symbol",
      "symbols": [
        "left",
        "right",
        "middle",
        "side",
        "extra",
        "forward",
        "back"
      ]
    },
    "Animator": {
      "kind": "class",
      "module": "GMR::Animator",
      "description": "TODO: Add description"
    },
    "Sound": {
      "kind": "class",
      "module": "GMR::Audio::Sound",
      "description": "TODO: Add description"
    },
    "Camera2D": {
      "kind": "class",
      "module": "Camera2D",
      "description": "TODO: Add description"
    },
    "CollisionResult": {
      "kind": "class",
      "module": "GMR::CollisionResult",
      "description": "TODO: Add description"
    },
    "Ease": {
      "kind": "class",
      "module": "GMR::Ease",
      "description": "TODO: Add description"
    },
    "Texture": {
      "kind": "class",
      "module": "GMR::Graphics::Texture",
      "description": "TODO: Add description"
    },
    "Tilemap": {
      "kind": "class",
      "module": "GMR::Graphics::Tilemap",
      "description": "TODO: Add description"
    },
    "Vec2": {
      "kind": "class",
      "module": "Vec2",
      "description": "TODO: Add description"
    },
    "Vec3": {
      "kind": "class",
      "module": "Vec3",
      "description": "TODO: Add description"
    },
    "Rect": {
      "kind": "class",
      "module": "Rect",
      "description": "TODO: Add description"
    },
    "Mathf": {
      "kind": "class",
      "module": "GMR::Mathf",
      "description": "TODO: Add description"
    },
    "Node": {
      "kind": "class",
      "module": "Node",
      "description": "TODO: Add description"
    },
    "Scene": {
      "kind": "class",
      "module": "GMR::Scene",
      "description": "TODO: Add description"
    },
    "SceneManager": {
      "kind": "class",
      "module": "GMR::SceneManager",
      "description": "TODO: Add description"
    },
    "Sprite": {
      "kind": "class",
      "module": "Sprite",
      "description": "TODO: Add description"
    },
    "SpriteAnimation": {
      "kind": "class",
      "module": "GMR::SpriteAnimation",
      "description": "TODO: Add description"
    },
    "StateMachine": {
      "kind": "class",
      "module": "GMR::StateMachine",
      "description": "TODO: Add description"
    },
    "Transform2D": {
      "kind": "class",
      "module": "Transform2D",
      "description": "TODO: Add description"
    },
    "Tween": {
      "kind": "class",
      "module": "GMR::Tween",
      "description": "TODO: Add description"
    },
    "GMR": {
      "kind": "class",
      "module": "GMR",
      "description": "TODO: Add description"
    }
  },
  "modules": {
    "GMR::Collision": {
      "description": "TODO: Add description",
      "functions": {
        "point_in_rect?": {
          "description": "Check if a point is inside a rectangle.",
          "params": [
            {
              "name": "px",
              "type": "Float",
              "description": "Point X coordinate"
            },
            {
              "name": "py",
              "type": "Float",
              "description": "Point Y coordinate"
            },
            {
              "name": "rx",
              "type": "Float",
              "description": "Rectangle X position (top-left)"
            },
            {
              "name": "ry",
              "type": "Float",
              "description": "Rectangle Y position (top-left)"
            },
            {
              "name": "rw",
              "type": "Float",
              "description": "Rectangle width"
            },
            {
              "name": "rh",
              "type": "Float",
              "description": "Rectangle height"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the point is inside the rectangle"
          },
          "example": "if GMR::Collision.point_in_rect?(mouse_x, mouse_y, btn.x, btn.y, btn.w, btn.h)\n  button_hovered = true\r\nend\r"
        },
        "point_in_circle?": {
          "description": "Check if a point is inside a circle.",
          "params": [
            {
              "name": "px",
              "type": "Float",
              "description": "Point X coordinate"
            },
            {
              "name": "py",
              "type": "Float",
              "description": "Point Y coordinate"
            },
            {
              "name": "cx",
              "type": "Float",
              "description": "Circle center X coordinate"
            },
            {
              "name": "cy",
              "type": "Float",
              "description": "Circle center Y coordinate"
            },
            {
              "name": "radius",
              "type": "Float",
              "description": "Circle radius"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the point is inside the circle"
          },
          "example": "if GMR::Collision.point_in_circle?(x, y, orb.x, orb.y, orb.radius)\n  orb.collect\r\nend\r"
        },
        "rect_overlap?": {
          "description": "Check if two rectangles overlap (AABB collision).",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First rectangle X position"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First rectangle Y position"
            },
            {
              "name": "w1",
              "type": "Float",
              "description": "First rectangle width"
            },
            {
              "name": "h1",
              "type": "Float",
              "description": "First rectangle height"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second rectangle X position"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second rectangle Y position"
            },
            {
              "name": "w2",
              "type": "Float",
              "description": "Second rectangle width"
            },
            {
              "name": "h2",
              "type": "Float",
              "description": "Second rectangle height"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the rectangles overlap"
          },
          "example": "if GMR::Collision.rect_overlap?(player.x, player.y, 32, 48,\n                                         platform.x, platform.y, 64, 16)\r\n  player.on_ground = true\r\nend\r"
        },
        "rect_contains?": {
          "description": "Check if the outer rectangle fully contains the inner rectangle.",
          "params": [
            {
              "name": "outer_x",
              "type": "Float",
              "description": "Outer rectangle X position"
            },
            {
              "name": "outer_y",
              "type": "Float",
              "description": "Outer rectangle Y position"
            },
            {
              "name": "outer_w",
              "type": "Float",
              "description": "Outer rectangle width"
            },
            {
              "name": "outer_h",
              "type": "Float",
              "description": "Outer rectangle height"
            },
            {
              "name": "inner_x",
              "type": "Float",
              "description": "Inner rectangle X position"
            },
            {
              "name": "inner_y",
              "type": "Float",
              "description": "Inner rectangle Y position"
            },
            {
              "name": "inner_w",
              "type": "Float",
              "description": "Inner rectangle width"
            },
            {
              "name": "inner_h",
              "type": "Float",
              "description": "Inner rectangle height"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the inner rectangle is fully inside the outer rectangle"
          },
          "example": "if GMR::Collision.rect_contains?(screen_x, screen_y, screen_w, screen_h,\n                                          entity.x, entity.y, entity.w, entity.h)\r\n  entity.draw  # Only draw if fully on screen\r\nend\r"
        },
        "circle_overlap?": {
          "description": "Check if two circles overlap.",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First circle center X"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First circle center Y"
            },
            {
              "name": "r1",
              "type": "Float",
              "description": "First circle radius"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second circle center X"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second circle center Y"
            },
            {
              "name": "r2",
              "type": "Float",
              "description": "Second circle radius"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the circles overlap"
          },
          "example": "if GMR::Collision.circle_overlap?(ball1.x, ball1.y, ball1.r,\n                                           ball2.x, ball2.y, ball2.r)\r\n  bounce_balls(ball1, ball2)\r\nend\r"
        },
        "circle_rect_overlap?": {
          "description": "Check if a circle overlaps with a rectangle.",
          "params": [
            {
              "name": "cx",
              "type": "Float",
              "description": "Circle center X"
            },
            {
              "name": "cy",
              "type": "Float",
              "description": "Circle center Y"
            },
            {
              "name": "cr",
              "type": "Float",
              "description": "Circle radius"
            },
            {
              "name": "rx",
              "type": "Float",
              "description": "Rectangle X position"
            },
            {
              "name": "ry",
              "type": "Float",
              "description": "Rectangle Y position"
            },
            {
              "name": "rw",
              "type": "Float",
              "description": "Rectangle width"
            },
            {
              "name": "rh",
              "type": "Float",
              "description": "Rectangle height"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the circle and rectangle overlap"
          },
          "example": "if GMR::Collision.circle_rect_overlap?(ball.x, ball.y, ball.r,\n                                                 wall.x, wall.y, wall.w, wall.h)\r\n  ball.bounce\r\nend\r"
        },
        "rect_tiles": {
          "description": "Get all tile coordinates that a rectangle overlaps. Useful for tile-based collision detection.",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "Rectangle X position"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "Rectangle Y position"
            },
            {
              "name": "w",
              "type": "Float",
              "description": "Rectangle width"
            },
            {
              "name": "h",
              "type": "Float",
              "description": "Rectangle height"
            },
            {
              "name": "tile_size",
              "type": "Integer",
              "description": "Size of each tile in pixels"
            }
          ],
          "returns": {
            "type": "Array<Array<Integer>>",
            "description": "Array of [tx, ty] tile coordinate pairs"
          },
          "example": "tiles = GMR::Collision.rect_tiles(player.x, player.y, 32, 48, 16)\n  tiles.each do |tx, ty|\r\n    if tilemap.solid?(tx, ty)\r\n      # Handle collision with this tile\r\n    end\r\n  end\r"
        },
        "tile_rect": {
          "description": "Convert tile coordinates to a world-space rectangle.",
          "params": [
            {
              "name": "tx",
              "type": "Integer",
              "description": "Tile X coordinate"
            },
            {
              "name": "ty",
              "type": "Integer",
              "description": "Tile Y coordinate"
            },
            {
              "name": "tile_size",
              "type": "Integer",
              "description": "Size of each tile in pixels"
            }
          ],
          "returns": {
            "type": "Array<Integer>",
            "description": "Rectangle as [x, y, width, height]"
          },
          "example": "x, y, w, h = GMR::Collision.tile_rect(5, 3, 16)\n  # Returns [80, 48, 16, 16]\r"
        },
        "tilemap_resolve": {
          "description": "Resolve collision between a hitbox rectangle and a tilemap's solid tiles. Returns a CollisionResult object with resolved position and collision flags. This is the recommended way to handle character-tilemap collisions in platformers.",
          "params": [
            {
              "name": "tilemap",
              "type": "Tilemap",
              "description": "The tilemap to check collision against"
            },
            {
              "name": "x",
              "type": "Float",
              "description": "Hitbox X position in tilemap local coordinates"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "Hitbox Y position in tilemap local coordinates"
            },
            {
              "name": "w",
              "type": "Float",
              "description": "Hitbox width"
            },
            {
              "name": "h",
              "type": "Float",
              "description": "Hitbox height"
            },
            {
              "name": "vx",
              "type": "Float",
              "description": "Current X velocity (for directional checks)"
            },
            {
              "name": "vy",
              "type": "Float",
              "description": "Current Y velocity (for directional checks)"
            }
          ],
          "returns": {
            "type": "CollisionResult",
            "description": "Collision result with position, velocity, and collision flags"
          },
          "example": "# In update loop:\n  local_x = @sprite.x + HITBOX_OFFSET_X - MAP_OFFSET_X\r\n  local_y = @sprite.y + HITBOX_OFFSET_Y - MAP_OFFSET_Y\r\n  result = Collision.tilemap_resolve(@tilemap, local_x, local_y, HITBOX_W, HITBOX_H, @vx, @vy)\r"
        },
        "distance": {
          "description": "Calculate the Euclidean distance between two points.",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First point X"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First point Y"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second point X"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second point Y"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Distance between the points"
          },
          "example": "dist = GMR::Collision.distance(player.x, player.y, enemy.x, enemy.y)\n  if dist < attack_range\r\n    attack_enemy(enemy)\r\n  end\r"
        },
        "distance_squared": {
          "description": "Calculate the squared distance between two points. Faster than distance() since it avoids the square root. Use for comparisons.",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First point X"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First point Y"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second point X"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second point Y"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Squared distance between the points"
          },
          "example": "# More efficient for distance comparisons\n  dist_sq = GMR::Collision.distance_squared(a.x, a.y, b.x, b.y)\r\n  if dist_sq < range * range\r\n    in_range = true\r\n  end\r"
        }
      }
    },
    "GMR::File": {
      "description": "TODO: Add description",
      "functions": {
        "read_text": {
          "params": [
            {
              "name": "path",
              "type": "String",
              "description": "Relative path to file (e.g., \"save.txt\" or \"config/settings.txt\")"
            },
            {
              "name": "root",
              "type": "Symbol",
              "description": "Logical root directory - :assets (read-only) or :data (writable). Default: :data"
            }
          ],
          "example": "# Read from assets\n  config = GMR::File.read_text(\"config.txt\", root: :assets)\r"
        },
        "read_bytes": {
          "params": [
            {
              "name": "path",
              "type": "String",
              "description": "Relative path to file"
            },
            {
              "name": "root",
              "type": "Symbol",
              "description": "Logical root directory - :assets or :data. Default: :data"
            }
          ],
          "example": "# Read binary data\n  bytes = GMR::File.read_bytes(\"level.dat\", root: :data)\r"
        },
        "read_json": {
          "params": [
            {
              "name": "path",
              "type": "String",
              "description": "Relative path to JSON file"
            },
            {
              "name": "root",
              "type": "Symbol",
              "description": "Logical root directory - :assets or :data. Default: :data"
            }
          ],
          "example": "# Read JSON save file\n  data = GMR::File.read_json(\"save.json\", root: :data)\r\n  puts data[\"level\"]  # Access parsed data\r"
        },
        "write_text": {
          "params": [
            {
              "name": "path",
              "type": "String",
              "description": "Relative path to file"
            },
            {
              "name": "content",
              "type": "String",
              "description": "Text content to write"
            },
            {
              "name": "root",
              "type": "Symbol",
              "description": "Logical root directory - must be :data (writes to :assets are rejected). Default: :data"
            }
          ],
          "example": "# Write log file\n  GMR::File.write_text(\"log.txt\", \"Game started\\n\", root: :data)\r"
        },
        "write_bytes": {
          "params": [
            {
              "name": "path",
              "type": "String",
              "description": "Relative path to file"
            },
            {
              "name": "data",
              "type": "String",
              "description": "Binary data to write"
            },
            {
              "name": "root",
              "type": "Symbol",
              "description": "Logical root directory - must be :data. Default: :data"
            }
          ],
          "example": "# Write binary data\n  GMR::File.write_bytes(\"level.dat\", binary_data, root: :data)\r"
        },
        "write_json": {
          "params": [
            {
              "name": "path",
              "type": "String",
              "description": "Relative path to file"
            },
            {
              "name": "data",
              "type": "Hash, Array",
              "description": "Ruby object to serialize as JSON"
            },
            {
              "name": "root",
              "type": "Symbol",
              "description": "Logical root directory - must be :data. Default: :data"
            },
            {
              "name": "pretty",
              "type": "Boolean",
              "description": "Format JSON with indentation. Default: false (minified)"
            }
          ],
          "example": "# Write JSON with pretty formatting\n  GMR::File.write_json(\"config.json\", data, root: :data, pretty: true)\r"
        },
        "exists?": {
          "params": [
            {
              "name": "path",
              "type": "String",
              "description": "Relative path to file"
            },
            {
              "name": "root",
              "type": "Symbol",
              "description": "Logical root directory - :assets or :data. Default: :data"
            }
          ],
          "example": "# Check if save file exists\n  if GMR::File.exists?(\"save.json\", root: :data)\r\n    data = GMR::File.read_json(\"save.json\", root: :data)\r\n  end\r"
        },
        "list_files": {
          "params": [
            {
              "name": "directory",
              "type": "String",
              "description": "Relative path to directory"
            },
            {
              "name": "root",
              "type": "Symbol",
              "description": "Logical root directory - :assets or :data. Default: :data"
            }
          ],
          "example": "# List save files\n  files = GMR::File.list_files(\"saves\", root: :data)\r\n  files.each { |f| puts f }  # \"save1.json\", \"save2.json\", ...\r"
        }
      }
    },
    "GMR::Graphics": {
      "description": "TODO: Add description",
      "functions": {
        "rgb": {
          "description": "Create a color array from RGB(A) values. Convenience helper.",
          "params": [
            {
              "name": "r",
              "type": "Integer",
              "description": "Red component (0-255)"
            },
            {
              "name": "g",
              "type": "Integer",
              "description": "Green component (0-255)"
            },
            {
              "name": "b",
              "type": "Integer",
              "description": "Blue component (0-255)"
            },
            {
              "name": "a",
              "type": "Integer",
              "description": "Alpha component (0-255, default: 255)"
            }
          ],
          "returns": {
            "type": "Array<Integer>",
            "description": "Color array [r, g, b, a]"
          },
          "example": "sprite.color = rgb(255, 100, 100)"
        },
        "clear": {
          "signature": "clear(color)",
          "description": "Clear the screen with a solid color",
          "params": [
            {
              "name": "color",
              "type": "Color",
              "description": "The background color (array, hex string, or named symbol)"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.clear(:dark_gray)"
        },
        "draw_rect": {
          "signature": "draw_rect(transform, width, height, color)",
          "description": "Draw a filled rectangle",
          "params": [
            {
              "name": "transform_or_x",
              "type": "Transform2D|Integer",
              "description": "Transform2D object OR X position (left edge)"
            },
            {
              "name": "width_or_y",
              "type": "Float|Integer",
              "description": "Width in pixels (if transform) OR Y position (top edge)"
            },
            {
              "name": "height_or_w",
              "type": "Float|Integer",
              "description": "Height in pixels (if transform) OR Width in pixels"
            },
            {
              "name": "color_or_h",
              "type": "Color|Integer",
              "description": "Fill color (if transform) OR Height in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Fill color (if using x,y,w,h)"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_rect(100, 100, 50, 30, [255, 0, 0])  # Legacy x,y,w,h"
        },
        "draw_rect_outline": {
          "signature": "draw_rect_outline(transform, width, height, color)",
          "description": "Draw a rectangle outline (not filled)",
          "params": [
            {
              "name": "transform_or_x",
              "type": "Transform2D|Integer",
              "description": "Transform2D object OR X position (left edge)"
            },
            {
              "name": "width_or_y",
              "type": "Float|Integer",
              "description": "Width in pixels (if transform) OR Y position (top edge)"
            },
            {
              "name": "height_or_w",
              "type": "Float|Integer",
              "description": "Height in pixels (if transform) OR Width in pixels"
            },
            {
              "name": "color_or_h",
              "type": "Color|Integer",
              "description": "Outline color (if transform) OR Height in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Outline color (if using x,y,w,h)"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_rect_outline(100, 100, 50, 30, [255, 255, 255])  # Legacy x,y,w,h"
        },
        "draw_rect_rotated": {
          "signature": "draw_rect_rotated(x, y, w, h, angle, color)",
          "description": "Draw a filled rectangle rotated around its center",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "X position (center)"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "Y position (center)"
            },
            {
              "name": "w",
              "type": "Float",
              "description": "Width in pixels"
            },
            {
              "name": "h",
              "type": "Float",
              "description": "Height in pixels"
            },
            {
              "name": "angle",
              "type": "Float",
              "description": "Rotation angle in degrees"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Fill color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_rect_rotated(160, 120, 40, 20, 45.0, [0, 255, 0])"
        },
        "draw_line": {
          "signature": "draw_line(transform, x1, y1, x2, y2, color, thickness=1.0)",
          "description": "Draw a line between two points",
          "params": [
            {
              "name": "transform_or_x1",
              "type": "Transform2D|Integer",
              "description": "Transform2D object OR Start X position"
            },
            {
              "name": "x1_or_y1",
              "type": "Float|Integer",
              "description": "Local X1 (if transform) OR Start Y position"
            },
            {
              "name": "y1_or_x2",
              "type": "Float|Integer",
              "description": "Local Y1 (if transform) OR End X position"
            },
            {
              "name": "x2_or_y2",
              "type": "Float|Integer",
              "description": "Local X2 (if transform) OR End Y position"
            },
            {
              "name": "y2_or_color",
              "type": "Float|Color",
              "description": "Local Y2 (if transform) OR Line color"
            },
            {
              "name": "color_or_thickness",
              "type": "Color|Float",
              "description": "Line color (if transform) OR Optional thickness"
            },
            {
              "name": "thickness",
              "type": "Float",
              "description": "Optional line thickness (default: 1.0, transform API only)"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_line(0, 0, 100, 100, :red, 3.0)  # Legacy with thickness"
        },
        "draw_line_thick": {
          "signature": "draw_line_thick(x1, y1, x2, y2, thickness, color)",
          "description": "Draw a thick line between two points",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "Start X position"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "Start Y position"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "End X position"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "End Y position"
            },
            {
              "name": "thickness",
              "type": "Float",
              "description": "Line thickness in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Line color"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_line_thick(0, 0, 100, 100, 3.0, [255, 200, 100])"
        },
        "draw_circle": {
          "signature": "draw_circle(transform, radius, color)",
          "description": "Draw a filled circle",
          "params": [
            {
              "name": "transform_or_x",
              "type": "Transform2D|Integer",
              "description": "Transform2D object OR Center X position"
            },
            {
              "name": "radius_or_y",
              "type": "Float|Integer",
              "description": "Radius in pixels (if transform) OR Center Y position"
            },
            {
              "name": "color_or_radius",
              "type": "Color|Integer",
              "description": "Fill color (if transform) OR Radius in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Fill color (if using x,y,radius)"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_circle(160, 120, 25, [100, 200, 255])  # Legacy x,y,radius"
        },
        "draw_circle_outline": {
          "signature": "draw_circle_outline(transform, radius, color)",
          "description": "Draw a circle outline",
          "params": [
            {
              "name": "transform_or_x",
              "type": "Transform2D|Integer",
              "description": "Transform2D object OR Center X position"
            },
            {
              "name": "radius_or_y",
              "type": "Float|Integer",
              "description": "Radius in pixels (if transform) OR Center Y position"
            },
            {
              "name": "color_or_radius",
              "type": "Color|Integer",
              "description": "Outline color (if transform) OR Radius in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Outline color (if using x,y,radius)"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_circle_outline(160, 120, 25, [255, 255, 255])  # Legacy x,y,radius"
        },
        "draw_circle_gradient": {
          "signature": "draw_circle_gradient(x, y, radius, inner_color, outer_color)",
          "description": "Draw a circle with a radial gradient from inner to outer color",
          "params": [
            {
              "name": "x",
              "type": "Integer",
              "description": "Center X position"
            },
            {
              "name": "y",
              "type": "Integer",
              "description": "Center Y position"
            },
            {
              "name": "radius",
              "type": "Integer",
              "description": "Circle radius in pixels"
            },
            {
              "name": "inner_color",
              "type": "Color",
              "description": "Color at center"
            },
            {
              "name": "outer_color",
              "type": "Color",
              "description": "Color at edge"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_circle_gradient(160, 120, 50, [255, 255, 255], [255, 0, 0, 0])"
        },
        "draw_triangle": {
          "signature": "draw_triangle(transform, x1, y1, x2, y2, x3, y3, color)",
          "description": "Draw a filled triangle",
          "params": [
            {
              "name": "transform_or_x1",
              "type": "Transform2D|Float",
              "description": "Transform2D object OR First vertex X"
            },
            {
              "name": "x1_or_y1",
              "type": "Float",
              "description": "Local X1 (if transform) OR First vertex Y"
            },
            {
              "name": "y1_or_x2",
              "type": "Float",
              "description": "Local Y1 (if transform) OR Second vertex X"
            },
            {
              "name": "x2_or_y2",
              "type": "Float",
              "description": "Local X2 (if transform) OR Second vertex Y"
            },
            {
              "name": "y2_or_x3",
              "type": "Float",
              "description": "Local Y2 (if transform) OR Third vertex X"
            },
            {
              "name": "x3_or_y3",
              "type": "Float",
              "description": "Local X3 (if transform) OR Third vertex Y"
            },
            {
              "name": "y3_or_color",
              "type": "Float|Color",
              "description": "Local Y3 (if transform) OR Fill color"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Fill color (if using transform)"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_triangle(100, 50, 50, 150, 150, 150, [255, 0, 0])  # Legacy world coords"
        },
        "draw_triangle_outline": {
          "signature": "draw_triangle_outline(transform, x1, y1, x2, y2, x3, y3, color)",
          "description": "Draw a triangle outline",
          "params": [
            {
              "name": "transform_or_x1",
              "type": "Transform2D|Float",
              "description": "Transform2D object OR First vertex X"
            },
            {
              "name": "x1_or_y1",
              "type": "Float",
              "description": "Local X1 (if transform) OR First vertex Y"
            },
            {
              "name": "y1_or_x2",
              "type": "Float",
              "description": "Local Y1 (if transform) OR Second vertex X"
            },
            {
              "name": "x2_or_y2",
              "type": "Float",
              "description": "Local X2 (if transform) OR Second vertex Y"
            },
            {
              "name": "y2_or_x3",
              "type": "Float",
              "description": "Local Y2 (if transform) OR Third vertex X"
            },
            {
              "name": "x3_or_y3",
              "type": "Float",
              "description": "Local X3 (if transform) OR Third vertex Y"
            },
            {
              "name": "y3_or_color",
              "type": "Float|Color",
              "description": "Local Y3 (if transform) OR Outline color"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Outline color (if using transform)"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_triangle_outline(100, 50, 50, 150, 150, 150, [255, 255, 255])  # Legacy world coords"
        },
        "draw_text": {
          "signature": "draw_text(transform, text, size, color)",
          "description": "Draw text at a position",
          "params": [
            {
              "name": "transform_or_text",
              "type": "Transform2D|String",
              "description": "Transform2D object OR The text to draw"
            },
            {
              "name": "text_or_x",
              "type": "String|Integer",
              "description": "Text content (if transform) OR X position (left edge)"
            },
            {
              "name": "size_or_y",
              "type": "Integer",
              "description": "Font size (if transform) OR Y position (top edge)"
            },
            {
              "name": "color_or_size",
              "type": "Color|Integer",
              "description": "Text color (if transform) OR Font size in pixels"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "Text color (if using x,y)"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Graphics.draw_text(\"Hello!\", 10, 10, 20, [255, 255, 255])  # Legacy x,y,size"
        },
        "measure_text": {
          "signature": "measure_text(text, size)",
          "description": "A loaded image texture for drawing sprites and images",
          "params": [
            {
              "name": "text",
              "type": "String",
              "description": "The text to measure"
            },
            {
              "name": "size",
              "type": "Integer",
              "description": "Font size in pixels"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Width in pixels"
          },
          "example": "width = GMR::Graphics.measure_text(\"Hello\", 20)"
        }
      }
    },
    "GMR::Input": {
      "description": "TODO: Add description",
      "functions": {
        "mouse_x": {
          "description": "Get the mouse X position in virtual resolution coordinates. Automatically accounts for letterboxing when using virtual resolution.",
          "returns": {
            "type": "Integer",
            "description": "Mouse X position"
          },
          "example": "x = GMR::Input.mouse_x"
        },
        "mouse_y": {
          "description": "Get the mouse Y position in virtual resolution coordinates. Automatically accounts for letterboxing when using virtual resolution.",
          "returns": {
            "type": "Integer",
            "description": "Mouse Y position"
          },
          "example": "y = GMR::Input.mouse_y"
        },
        "mouse_down?": {
          "description": "Check if a mouse button is currently held down.",
          "params": [
            {
              "name": "button",
              "type": "Symbol, Integer",
              "description": "The button to check (:left, :right, :middle, or constant)"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the button is held"
          },
          "example": "if GMR::Input.mouse_down?(:left)\n  player.aim\r\nend\r"
        },
        "mouse_pressed?": {
          "description": "Check if a mouse button was just pressed this frame.",
          "params": [
            {
              "name": "button",
              "type": "Symbol, Integer",
              "description": "The button to check (:left, :right, :middle, or constant)"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the button was just pressed"
          },
          "example": "if GMR::Input.mouse_pressed?(:left)\n  player.shoot\r\nend\r"
        },
        "mouse_released?": {
          "description": "Check if a mouse button was just released this frame.",
          "params": [
            {
              "name": "button",
              "type": "Symbol, Integer",
              "description": "The button to check (:left, :right, :middle, or constant)"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the button was just released"
          },
          "example": "if GMR::Input.mouse_released?(:left)\n  bow.release_arrow\r\nend\r"
        },
        "mouse_wheel": {
          "description": "Get the mouse wheel movement this frame. Positive values indicate scrolling up/forward, negative values indicate scrolling down/backward.",
          "returns": {
            "type": "Float",
            "description": "Wheel movement amount"
          },
          "example": "zoom += GMR::Input.mouse_wheel * 0.1"
        },
        "key_down?": {
          "description": "Check if a key is currently held down. Accepts a single key or an array of keys (returns true if any key in the array is held).",
          "params": [
            {
              "name": "key",
              "type": "Symbol, Integer, Array",
              "description": "The key(s) to check (:space, :a, :left, etc.)"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the key (or any key in array) is held"
          },
          "example": "if GMR::Input.key_down?([:a, :left])  # Either key works\n  player.move_left\r\nend\r"
        },
        "key_pressed?": {
          "description": "Check if a key was just pressed this frame. Accepts a single key or an array of keys (returns true if any key in the array was just pressed).",
          "params": [
            {
              "name": "key",
              "type": "Symbol, Integer, Array",
              "description": "The key(s) to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the key (or any key in array) was just pressed"
          },
          "example": "if GMR::Input.key_pressed?(:space)\n  player.jump\r\nend\r"
        },
        "key_released?": {
          "description": "Check if a key was just released this frame. Accepts a single key or an array of keys (returns true if any key in the array was just released).",
          "params": [
            {
              "name": "key",
              "type": "Symbol, Integer, Array",
              "description": "The key(s) to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the key (or any key in array) was just released"
          },
          "example": "if GMR::Input.key_released?(:shift)\n  player.stop_running\r\nend\r"
        },
        "key_pressed": {
          "description": "Get the key code of the last key pressed this frame. Useful for text input or detecting any key press.",
          "returns": {
            "type": "Integer, nil",
            "description": "Key code, or nil if no key was pressed"
          },
          "example": "key = GMR::Input.key_pressed\n  if key\r\n    puts \"Key code: #{key}\"\r\n  end\r"
        },
        "char_pressed": {
          "description": "Get the Unicode character code of the last character pressed this frame. Useful for text input fields. Returns the character, not the key code.",
          "returns": {
            "type": "Integer, nil",
            "description": "Unicode character code, or nil if no character was pressed"
          },
          "example": "char = GMR::Input.char_pressed\n  if char\r"
        },
        "map": {
          "description": "Map an action name to input bindings. Supports two forms: Traditional form maps a single action to keys directly. Block form allows defining multiple actions with a DSL.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "(optional) The action name for traditional form"
            },
            {
              "name": "keys",
              "type": "Symbol, Array",
              "description": "(optional) Key(s) to bind for traditional form"
            }
          ],
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "# Block DSL form\n  GMR::Input.map do |i|\r\n    i.action :jump, key: :space\r\n    i.action :attack, keys: [:z, :x], mouse: :left\r\n  end\r"
        },
        "unmap": {
          "description": "Remove an action mapping by name.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The action name to remove"
            }
          ],
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "GMR::Input.unmap(:jump).unmap(:attack)"
        },
        "clear_mappings": {
          "description": "Remove all action mappings.",
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "GMR::Input.clear_mappings.map(:new_action, :space)"
        },
        "action_down?": {
          "description": "Check if a mapped action is currently active (any bound input is held).",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The action name to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the action is active"
          },
          "example": "if GMR::Input.action_down?(:move_left)\n  player.x -= speed\r\nend\r"
        },
        "action_pressed?": {
          "description": "Check if a mapped action was just triggered this frame.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The action name to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the action was just triggered"
          },
          "example": "if GMR::Input.action_pressed?(:jump)\n  player.jump\r\nend\r"
        },
        "action_released?": {
          "description": "Check if a mapped action was just released this frame.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The action name to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the action was just released"
          },
          "example": "if GMR::Input.action_released?(:charge_attack)\n  player.release_charge\r\nend\r"
        },
        "on": {
          "description": "Register a callback for an action. The callback fires when the action reaches the specified phase. Returns an ID for later removal with `off`.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The action name to listen for"
            },
            {
              "name": "when",
              "type": "Symbol",
              "description": "(optional, default: :pressed) Phase: :pressed, :down, or :released"
            },
            {
              "name": "context",
              "type": "Object",
              "description": "(optional) Object to use as self in the callback block"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Callback ID for later removal"
          },
          "example": "# With phase and context\n  id = GMR::Input.on(:attack, when: :released, context: player) do\r\n    release_charge_attack\r\n  end\r\n  GMR::Input.off(id)  # Remove later\r"
        },
        "off": {
          "description": "Remove input callback(s). Pass an ID to remove a specific callback, or an action name to remove all callbacks for that action.",
          "params": [
            {
              "name": "id_or_action",
              "type": "Integer, Symbol",
              "description": "Callback ID or action name"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "GMR::Input.off(:jump)        # Remove all :jump callbacks"
        },
        "push_context": {
          "description": "Push a named input context onto the stack. Actions defined in this context become active. Previous contexts remain on the stack.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The context name to push"
            },
            {
              "name": "blocks_global",
              "type": "Boolean",
              "description": "(optional) If true, global actions are blocked while this context is active"
            }
          ],
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "GMR::Input.push_context(:pause, blocks_global: true)\n  # :pause actions active, global game actions blocked\r"
        },
        "pop_context": {
          "description": "Pop the current input context from the stack, returning to the previous context.",
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "GMR::Input.pop_context  # Return to previous context"
        },
        "set_context": {
          "description": "Replace the entire context stack with a single context. Clears the stack and sets the named context as the only active context.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The context name to set"
            }
          ],
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "GMR::Input.set_context(:gameplay)"
        },
        "current_context": {
          "description": "Get the name of the current active input context.",
          "returns": {
            "type": "Symbol, nil",
            "description": "Current context name, or nil if no context is active"
          },
          "example": "context = GMR::Input.current_context"
        },
        "has_context?": {
          "description": "Check if a named input context exists (has been defined).",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The context name to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the context exists"
          },
          "example": "if GMR::Input.has_context?(:menu)\n  GMR::Input.push_context(:menu)\r\nend\r"
        },
        "input": {
          "description": "Define global input actions using a verb-style DSL. Actions defined here are always available regardless of context.",
          "returns": {
            "type": "nil"
          },
          "example": "input do |i|\n  i.jump :space\r\n  i.move_left [:a, :left]\r\n  i.attack :z, mouse: :left\r\nend\r"
        },
        "input_context": {
          "description": "Define input actions for a named context. Context-specific actions are only active when that context is pushed onto the stack.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The context name"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "input_context :menu do |i|\n  i.confirm :enter\r\n  i.cancel :escape\r\n  i.navigate_up :up\r\n  i.navigate_down :down\r\nend\r"
        }
      }
    },
    "GMR::Storage": {
      "description": "TODO: Add description",
      "functions": {
        "get": {
          "params": [
            {
              "name": "key",
              "type": "String, Symbol",
              "description": "Storage key (e.g., \"high_score\", :volume)"
            },
            {
              "name": "default",
              "type": "Integer",
              "description": "Default value if key doesn't exist (default: 0)"
            }
          ],
          "example": "# Get volume with default\n  volume = GMR::Storage.get(:volume, 80)\r"
        },
        "set": {
          "params": [
            {
              "name": "key",
              "type": "String, Symbol",
              "description": "Storage key (e.g., \"high_score\", :volume)"
            },
            {
              "name": "value",
              "type": "Integer",
              "description": "Value to store"
            }
          ],
          "example": "# Save volume setting\n  GMR::Storage.set(:volume, 80)\r"
        },
        "has_key?": {
          "params": [
            {
              "name": "key",
              "type": "String, Symbol",
              "description": "Storage key to check"
            }
          ],
          "example": "# Check if high score exists\n  if GMR::Storage.has_key?(\"high_score\")\r\n    score = GMR::Storage.get(\"high_score\")\r\n  end\r"
        },
        "delete": {
          "params": [
            {
              "name": "key",
              "type": "String, Symbol",
              "description": "Storage key to delete"
            }
          ],
          "example": "# Delete high score\n  GMR::Storage.delete(\"high_score\")\r"
        },
        "increment": {
          "params": [
            {
              "name": "key",
              "type": "String, Symbol",
              "description": "Storage key to increment"
            },
            {
              "name": "amount",
              "type": "Integer",
              "description": "Amount to add (default: 1)"
            }
          ],
          "example": "# Add to score\n  GMR::Storage.increment(\"total_score\", 100)\r"
        },
        "decrement": {
          "params": [
            {
              "name": "key",
              "type": "String, Symbol",
              "description": "Storage key to decrement"
            },
            {
              "name": "amount",
              "type": "Integer",
              "description": "Amount to subtract (default: 1)"
            }
          ],
          "example": "# Subtract from currency\n  GMR::Storage.decrement(\"gold\", 50)\r"
        }
      }
    },
    "GMR::System": {
      "description": "TODO: Add description",
      "functions": {
        "quit": {
          "description": "Immediately exit the application. Closes the window and terminates the process.",
          "returns": {
            "type": "nil"
          },
          "example": "GMR::System.quit  # Exit the game"
        },
        "platform": {
          "description": "Get the current platform identifier.",
          "returns": {
            "type": "String",
            "description": "Platform name: \"windows\", \"macos\", \"linux\", \"web\", or \"unknown\""
          },
          "example": "if GMR::System.platform == \"web\"\n  # Disable desktop-only features\r\nend\r"
        },
        "build_type": {
          "description": "Get the build configuration type.",
          "returns": {
            "type": "String",
            "description": "Build type: \"debug\", \"release\", or \"unknown\""
          },
          "example": "if GMR::System.build_type == \"debug\"\n  enable_debug_overlay\r\nend\r"
        },
        "compiled_scripts?": {
          "description": "Check if scripts were precompiled into the binary.",
          "returns": {
            "type": "Boolean",
            "description": "true if scripts are compiled in, false if loading from files"
          },
          "example": "puts \"Scripts compiled: #{GMR::System.compiled_scripts?}\""
        },
        "raylib_version": {
          "description": "Get the version of the underlying Raylib graphics library.",
          "returns": {
            "type": "String",
            "description": "Raylib version string (e.g., \"5.0\")"
          },
          "example": "puts \"Raylib: #{GMR::System.raylib_version}\""
        },
        "gpu_vendor": {
          "description": "Get the GPU vendor name from OpenGL.",
          "returns": {
            "type": "String",
            "description": "GPU vendor name (e.g., \"NVIDIA Corporation\") or \"unknown\""
          },
          "example": "puts \"GPU Vendor: #{GMR::System.gpu_vendor}\""
        },
        "gpu_renderer": {
          "description": "Get the GPU renderer name from OpenGL.",
          "returns": {
            "type": "String",
            "description": "GPU renderer name (e.g., \"GeForce RTX 3080\") or \"WebGL\""
          },
          "example": "puts \"GPU: #{GMR::System.gpu_renderer}\""
        },
        "gl_version": {
          "description": "Get the OpenGL version string.",
          "returns": {
            "type": "String",
            "description": "OpenGL version (e.g., \"4.6.0\") or \"WebGL 2.0\""
          },
          "example": "puts \"OpenGL: #{GMR::System.gl_version}\""
        },
        "glsl_version": {
          "description": "Get the GLSL (shader language) version string.",
          "returns": {
            "type": "String",
            "description": "GLSL version (e.g., \"4.60\") or \"GLSL ES 3.00\""
          },
          "example": "puts \"GLSL: #{GMR::System.glsl_version}\""
        },
        "last_error": {
          "description": "Get details about the last script error. Returns nil if no error occurred.",
          "returns": {
            "type": "Hash, nil",
            "description": "Error hash with keys :class, :message, :file, :line, :backtrace, or nil"
          },
          "example": "error = GMR::System.last_error\n  if error\r\n    puts \"#{error[:class]}: #{error[:message]}\"\r\n    puts \"  at #{error[:file]}:#{error[:line]}\"\r\n    error[:backtrace].each { |line| puts \"    #{line}\" }\r\n  end\r"
        },
        "in_error_state?": {
          "description": "Check if the scripting engine is currently in an error state.",
          "returns": {
            "type": "Boolean",
            "description": "true if an unhandled error has occurred"
          },
          "example": "if GMR::System.in_error_state?\n  show_error_screen\r\nend\r"
        }
      }
    },
    "GMR::Window": {
      "description": "TODO: Add description",
      "functions": {
        "width": {
          "description": "Get the logical width of the game screen. Returns virtual resolution width if set, otherwise the actual window width.",
          "returns": {
            "type": "Integer",
            "description": "Screen width in pixels"
          },
          "example": "screen_w = GMR::Window.width"
        },
        "height": {
          "description": "Get the logical height of the game screen. Returns virtual resolution height if set, otherwise the actual window height.",
          "returns": {
            "type": "Integer",
            "description": "Screen height in pixels"
          },
          "example": "screen_h = GMR::Window.height"
        },
        "actual_width": {
          "description": "Get the actual window width in pixels, ignoring virtual resolution.",
          "returns": {
            "type": "Integer",
            "description": "Actual window width"
          },
          "example": "real_w = GMR::Window.actual_width"
        },
        "actual_height": {
          "description": "Get the actual window height in pixels, ignoring virtual resolution.",
          "returns": {
            "type": "Integer",
            "description": "Actual window height"
          },
          "example": "real_h = GMR::Window.actual_height"
        },
        "set_size": {
          "description": "Set the window size. Has no effect in fullscreen mode.",
          "params": [
            {
              "name": "w",
              "type": "Integer",
              "description": "Window width in pixels"
            },
            {
              "name": "h",
              "type": "Integer",
              "description": "Window height in pixels"
            }
          ],
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "GMR::Window.set_size(1280, 720).set_title(\"My Game\")"
        },
        "set_title": {
          "description": "Set the window title bar text.",
          "params": [
            {
              "name": "title",
              "type": "String",
              "description": "The window title"
            }
          ],
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "GMR::Window.set_title(\"My Awesome Game\")"
        },
        "toggle_fullscreen": {
          "description": "Toggle between fullscreen and windowed mode.",
          "returns": {
            "type": "Boolean",
            "description": "true"
          },
          "example": "GMR::Window.toggle_fullscreen"
        },
        "fullscreen=": {
          "description": "Set fullscreen mode on or off.",
          "params": [
            {
              "name": "fullscreen",
              "type": "Boolean",
              "description": "true for fullscreen, false for windowed"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "The fullscreen state that was set"
          },
          "example": "GMR::Window.fullscreen = true"
        },
        "fullscreen?": {
          "description": "Check if the window is currently in fullscreen mode.",
          "returns": {
            "type": "Boolean",
            "description": "true if fullscreen"
          },
          "example": "if GMR::Window.fullscreen?\n  show_windowed_mode_button\r\nend\r"
        },
        "set_virtual_resolution": {
          "description": "Set a virtual resolution for pixel-perfect rendering. The game renders to this resolution and scales to fit the window with letterboxing.",
          "params": [
            {
              "name": "w",
              "type": "Integer",
              "description": "Virtual width in pixels"
            },
            {
              "name": "h",
              "type": "Integer",
              "description": "Virtual height in pixels"
            }
          ],
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "# Render at 320x240 for retro-style game\n  GMR::Window.set_virtual_resolution(320, 240).set_filter_point\r"
        },
        "clear_virtual_resolution": {
          "description": "Disable virtual resolution and render directly at window size.",
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "GMR::Window.clear_virtual_resolution"
        },
        "virtual_resolution?": {
          "description": "Check if virtual resolution is currently enabled.",
          "returns": {
            "type": "Boolean",
            "description": "true if virtual resolution is active"
          },
          "example": "if GMR::Window.virtual_resolution?\n  puts \"Using virtual resolution\"\r\nend\r"
        },
        "set_filter_point": {
          "description": "Set nearest-neighbor (point) filtering for virtual resolution scaling. Produces crisp, pixelated look. Only works when virtual resolution is enabled.",
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "GMR::Window.set_virtual_resolution(320, 240).set_filter_point"
        },
        "set_filter_bilinear": {
          "description": "Set bilinear filtering for virtual resolution scaling. Produces smoother, blended scaling. Only works when virtual resolution is enabled.",
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "GMR::Window.set_virtual_resolution(320, 240).set_filter_bilinear"
        },
        "monitor_count": {
          "description": "Get the number of connected monitors.",
          "returns": {
            "type": "Integer",
            "description": "Number of monitors"
          },
          "example": "count = GMR::Window.monitor_count"
        },
        "monitor_width": {
          "description": "Get the width of a specific monitor.",
          "params": [
            {
              "name": "index",
              "type": "Integer",
              "description": "Monitor index (0-based)"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Monitor width in pixels"
          },
          "example": "w = GMR::Window.monitor_width(0)  # Primary monitor"
        },
        "monitor_height": {
          "description": "Get the height of a specific monitor.",
          "params": [
            {
              "name": "index",
              "type": "Integer",
              "description": "Monitor index (0-based)"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Monitor height in pixels"
          },
          "example": "h = GMR::Window.monitor_height(0)"
        },
        "monitor_refresh_rate": {
          "description": "Get the refresh rate of a specific monitor.",
          "params": [
            {
              "name": "index",
              "type": "Integer",
              "description": "Monitor index (0-based)"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Refresh rate in Hz"
          },
          "example": "hz = GMR::Window.monitor_refresh_rate(0)"
        },
        "monitor_name": {
          "description": "Time and frame rate utilities. Provides delta time for frame-independent movement, elapsed time tracking, and FPS management.",
          "params": [
            {
              "name": "index",
              "type": "Integer",
              "description": "Monitor index (0-based)"
            }
          ],
          "returns": {
            "type": "String",
            "description": "Monitor name"
          },
          "example": "# Debug overlay with FPS and timing info\n  class DebugOverlay\r\n    def draw\r\n      y = 10\r\n      color = [0, 255, 0]\r\n\n      # Show current FPS\r\n      fps = GMR::Time.fps\r\n      fps_color = fps < 30 ? [255, 0, 0] : fps < 55 ? [255, 255, 0] : [0, 255, 0]\r\n      GMR::Graphics.draw_text(\"FPS: #{fps}\", 10, y, 16, fps_color)\r\n      y += 20\r\n\n      # Show frame time\r\n      frame_ms = (GMR::Time.delta * 1000).round(2)\r\n      GMR::Graphics.draw_text(\"Frame: #{frame_ms}ms\", 10, y, 16, color)\r\n      y += 20\r\n\n      # Show total elapsed time\r\n      elapsed = GMR::Time.elapsed\r\n      minutes = (elapsed / 60).to_i\r\n      seconds = (elapsed % 60).to_i\r\n      GMR::Graphics.draw_text(\"Time: #{minutes}:#{seconds.to_s.rjust(2, '0')}\", 10, y, 16, color)\r\n    end\r\n  end\r"
        }
      }
    },
    "GMR::Time": {
      "description": "TODO: Add description",
      "functions": {
        "delta": {
          "description": "Get the time elapsed since the last frame in seconds. Use this for frame-independent movement and animation.",
          "returns": {
            "type": "Float",
            "description": "Delta time in seconds"
          },
          "example": "# Move at 100 pixels per second regardless of frame rate\n  player.x += 100 * GMR::Time.delta\r"
        },
        "elapsed": {
          "description": "Get the total time elapsed since the game started in seconds.",
          "returns": {
            "type": "Float",
            "description": "Total elapsed time in seconds"
          },
          "example": "# Flash effect every 0.5 seconds\n  visible = (GMR::Time.elapsed % 1.0) < 0.5\r"
        },
        "fps": {
          "description": "Get the current frames per second.",
          "returns": {
            "type": "Integer",
            "description": "Current FPS"
          },
          "example": "puts \"FPS: #{GMR::Time.fps}\""
        },
        "set_target_fps": {
          "description": "Set the target frame rate. The game will try to maintain this FPS. Set to 0 for unlimited frame rate.",
          "params": [
            {
              "name": "fps",
              "type": "Integer",
              "description": "Target frames per second"
            }
          ],
          "returns": {
            "type": "Module",
            "description": "self for chaining"
          },
          "example": "GMR::Time.set_target_fps(60)  # Lock to 60 FPS"
        }
      }
    },
    "GMR": {
      "kind": "class",
      "description": "TODO: Add description",
      "classMethods": {
        "lerp_position": {
          "signature": "lerp_position(arg1, arg2, arg3)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Object"
            },
            {
              "name": "arg2",
              "type": "Object"
            },
            {
              "name": "arg3",
              "type": "Float"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "lerp_rotation": {
          "signature": "lerp_rotation(arg1, arg2, arg3)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Float"
            },
            {
              "name": "arg2",
              "type": "Float"
            },
            {
              "name": "arg3",
              "type": "Float"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "lerp_scale": {
          "signature": "lerp_scale(arg1, arg2, arg3)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Object"
            },
            {
              "name": "arg2",
              "type": "Object"
            },
            {
              "name": "arg3",
              "type": "Float"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        }
      },
      "instanceMethods": {
        "inspect": {
          "signature": "inspect",
          "description": "TODO: Add documentation",
          "params": [],
          "returns": {
            "type": "unknown"
          }
        }
      }
    },
    "GMR::Animator": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new animator for a sprite. The animator manages the sprite's source_rect automatically based on the current animation frame.",
          "params": [
            {
              "name": "sprite",
              "type": "Sprite",
              "description": "The sprite to animate"
            }
          ],
          "example": "# Infer frame size from sprite's source_rect"
        },
        "add": {
          "description": "Add a named animation. Frame indices correspond to positions in the spritesheet grid (left-to-right, top-to-bottom). For example, in an 8-column sheet: - Frame 0 = row 0, col 0 - Frame 7 = row 0, col 7 - Frame 8 = row 1, col 0",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "Animation name (e.g., :idle, :run, :attack)"
            }
          ],
          "returns": {
            "type": "Animator",
            "description": "self for chaining"
          },
          "example": "# Using explicit frame arrays for non-sequential animations"
        },
        "allow_transition": {
          "description": "Allow transition from one animation to another. If no transition rules are defined, all transitions are allowed by default. Once you define any rule, only explicitly allowed transitions will work.",
          "params": [
            {
              "name": "from",
              "type": "Symbol",
              "description": "Source animation name"
            },
            {
              "name": "to",
              "type": "Symbol",
              "description": "Destination animation name"
            }
          ],
          "returns": {
            "type": "Animator",
            "description": "self for chaining"
          },
          "example": "# Platformer character state flow\n  # Ground states can go to each other and to jump\r"
        },
        "allow_from_any": {
          "description": "Allow this animation to be played from any other animation. Useful for high-priority animations like \"hurt\" or \"death\" that can interrupt anything. This bypasses all transition rules for the specified animation.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "Animation name that can interrupt any animation"
            }
          ],
          "returns": {
            "type": "Animator",
            "description": "self for chaining"
          },
          "example": "# Use case: Enemy interrupts player attack with counter\n  def take_damage\r\n    # Even if player is mid-attack, hurt animation plays immediately\r"
        },
        "play": {
          "description": "Switch to a named animation. Checks transition rules before switching. If the requested animation is already playing, this does nothing. If transition rules exist and the transition is not allowed, this does nothing.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "Animation name to play"
            }
          ],
          "returns": {
            "type": "Animator",
            "description": "self for chaining"
          },
          "example": "# Conditional play with transition check\n  def try_attack\r\n    if @animator.can_play?(:attack)\r"
        },
        "stop": {
          "description": "Stop the current animation and clear any queued animation. The sprite will freeze on the current frame.",
          "returns": {
            "type": "Animator",
            "description": "self for chaining"
          },
          "example": "# Stop animation when character dies\n  def die\r"
        },
        "current": {
          "description": "Get the current animation name.",
          "returns": {
            "type": "Symbol, nil",
            "description": "Current animation name or nil if no animation is set"
          },
          "example": "# Debug output\n  def draw\r"
        },
        "playing?": {
          "description": "Check if any animation is currently playing (not stopped/completed).",
          "returns": {
            "type": "Boolean",
            "description": "true if an animation is actively playing"
          },
          "example": "# Check if death animation finished\n  def update(dt)\r\n    if @animator.current == :death && !@animator.playing?\r\n      remove_from_game\r\n    end\r\n  end\r"
        },
        "can_play?": {
          "description": "Check if transition to the given animation is allowed from current. Returns false if the animation doesn't exist or if transition rules block it.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "Animation name to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if transition is allowed"
          },
          "example": "# AI decision making based on available animations\n  def ai_update\r\n    if @animator.can_play?(:attack) && player_in_range?\r"
        },
        "on_complete": {
          "description": "Set a callback for when a specific animation completes. The callback is invoked when the named non-looping animation finishes.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "Animation name to attach callback to"
            }
          ],
          "returns": {
            "type": "Animator",
            "description": "self for chaining"
          },
          "example": "# Death animation cleanup"
        },
        "[]": {
          "description": "Get animation info by name. Returns a hash with fps, loop, frame_count, and playing status.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "Animation name"
            }
          ],
          "returns": {
            "type": "Hash, nil",
            "description": "Animation info hash or nil if animation doesn't exist"
          },
          "example": "# Dynamic FPS adjustment based on game state\n  if @speed_boost_active\r\n    current_info = @animator[@animator.current]\r\n    # Note: Would need fps= method to modify (not currently implemented)\r\n  end\r"
        },
        "count": {
          "description": "Get the number of active animators in the game. Class method.",
          "returns": {
            "type": "Integer",
            "description": "Number of active animators"
          },
          "example": "# Debug: show animator count\n  Graphics.draw_text(\"Animators: #{Animator.count}\", 10, 10, 16, [255,255,255])\r"
        }
      }
    },
    "GMR::Audio::Sound": {
      "kind": "class",
      "description": "TODO: Add description",
      "classMethods": {
        "load": {
          "description": "Load a sound file from disk. Supports WAV, OGG, MP3, and other formats.",
          "params": [
            {
              "name": "path",
              "type": "String",
              "description": "Path to the audio file"
            }
          ],
          "returns": {
            "type": "Sound",
            "description": "The loaded sound object"
          },
          "raises": [
            "RuntimeError If the file cannot be loaded"
          ],
          "example": "jump_sound = GMR::Audio::Sound.load(\"assets/sfx/jump.wav\")"
        }
      },
      "instanceMethods": {
        "play": {
          "description": "Play the sound. Can be called multiple times for overlapping playback.",
          "returns": {
            "type": "nil"
          },
          "example": "sound.play"
        },
        "stop": {
          "description": "Stop the sound if it's currently playing.",
          "returns": {
            "type": "nil"
          },
          "example": "sound.stop"
        },
        "volume=": {
          "description": "Set the playback volume for this sound.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "Volume level from 0.0 (silent) to 1.0 (full volume)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The volume that was set"
          },
          "example": "sound.volume = 0.5  # Half volume"
        }
      }
    },
    "Camera2D": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Camera2D with optional initial values.",
          "params": [
            {
              "name": "target",
              "type": "Vec2",
              "description": "World position the camera looks at (default: 0,0)"
            },
            {
              "name": "offset",
              "type": "Vec2",
              "description": "Screen position offset, typically screen center (default: 0,0)"
            },
            {
              "name": "zoom",
              "type": "Float",
              "description": "Zoom level, 1.0 = normal (default: 1.0)"
            },
            {
              "name": "rotation",
              "type": "Float",
              "description": "Rotation in degrees (default: 0)"
            }
          ],
          "returns": {
            "type": "Camera2D",
            "description": "The new camera"
          },
          "example": "cam = Camera2D.new(offset: Vec2.new(400, 300))  # Center on 800x600 screen"
        },
        "target": {
          "description": "Get the world position the camera is looking at.",
          "returns": {
            "type": "Vec2",
            "description": "The camera's target position"
          },
          "example": "target = camera.target"
        },
        "offset": {
          "description": "Get the screen position offset (where the target appears on screen). Typically set to screen center for centered camera following.",
          "returns": {
            "type": "Vec2",
            "description": "The camera's offset position"
          },
          "example": "offset = camera.offset"
        },
        "zoom": {
          "description": "Get the zoom level. 1.0 = normal, 2.0 = 2x magnification, 0.5 = zoomed out.",
          "returns": {
            "type": "Float",
            "description": "The zoom level"
          },
          "example": "z = camera.zoom"
        },
        "rotation": {
          "description": "Get the camera rotation in degrees.",
          "returns": {
            "type": "Float",
            "description": "The rotation angle"
          },
          "example": "angle = camera.rotation"
        },
        "target=": {
          "description": "Set the world position the camera looks at.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The target position"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "camera.target = player.position"
        },
        "offset=": {
          "description": "Set the screen position offset. The target appears at this screen position. Set to screen center for centered following.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The offset position"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "camera.offset = Vec2.new(400, 300)  # Center on 800x600 screen"
        },
        "zoom=": {
          "description": "Set the zoom level. 1.0 = normal, 2.0 = 2x magnification, 0.5 = zoomed out.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The zoom level (must be > 0)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "camera.zoom = 0.5    # Zoom out (see more of the world)"
        },
        "rotation=": {
          "description": "Set the camera rotation in degrees.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The rotation angle in degrees"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "camera.rotation += 10 * dt  # Rotate over time"
        },
        "follow": {
          "description": "Configure the camera to follow a target object with optional smoothing and deadzone. The target must respond to `position` (returning Vec2) or have `x`/`y` methods. Call with nil to stop following.",
          "params": [
            {
              "name": "target",
              "type": "Object, nil",
              "description": "Object with position/x/y to follow, or nil to stop"
            },
            {
              "name": "smoothing",
              "type": "Float",
              "description": "Smoothing factor 0-1 (0=instant, 0.1=smooth, default: 0)"
            },
            {
              "name": "deadzone",
              "type": "Rect",
              "description": "Rectangle where target can move without camera moving"
            }
          ],
          "returns": {
            "type": "Camera2D",
            "description": "self for chaining"
          },
          "example": "# Stop following\n  camera.follow(nil)\r"
        },
        "bounds=": {
          "description": "Set camera bounds to constrain movement within a world region. The camera will not show areas outside these bounds. Set to nil to remove bounds.",
          "params": [
            {
              "name": "value",
              "type": "Rect, nil",
              "description": "The world bounds, or nil to remove"
            }
          ],
          "returns": {
            "type": "Rect, nil",
            "description": "The value that was set"
          },
          "example": "camera.bounds = nil  # No bounds"
        },
        "bounds": {
          "description": "Get the current camera bounds. Returns nil if no bounds are set.",
          "returns": {
            "type": "Rect, nil",
            "description": "The world bounds, or nil if unbounded"
          },
          "example": "rect = camera.bounds"
        },
        "shake": {
          "description": "Trigger a screen shake effect. The shake decays over the duration.",
          "params": [
            {
              "name": "strength",
              "type": "Float",
              "description": "Maximum shake offset in pixels (default: 5.0)"
            },
            {
              "name": "duration",
              "type": "Float",
              "description": "How long the shake lasts in seconds (default: 0.3)"
            },
            {
              "name": "frequency",
              "type": "Float",
              "description": "Shake oscillation frequency in Hz (default: 30.0)"
            }
          ],
          "returns": {
            "type": "Camera2D",
            "description": "self for chaining"
          },
          "example": "camera.shake(strength: 3, duration: 0.2, frequency: 20)"
        },
        "world_to_screen": {
          "description": "Convert a world position to screen coordinates. Useful for placing UI elements relative to game objects.",
          "params": [
            {
              "name": "position",
              "type": "Vec2",
              "description": "The world position"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The screen position"
          },
          "example": "health_bar_x = camera.world_to_screen(enemy.position).x"
        },
        "screen_to_world": {
          "description": "Convert a screen position to world coordinates. Useful for mouse picking and click-to-move.",
          "params": [
            {
              "name": "position",
              "type": "Vec2",
              "description": "The screen position"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The world position"
          },
          "example": "click_target = camera.screen_to_world(Vec2.new(mouse_x, mouse_y))"
        },
        "use": {
          "description": "Execute a block with this camera's transform applied. All sprites drawn within the block will be rendered with the camera transform applied during the deferred rendering pass. This works correctly with z-ordering.",
          "returns": {
            "type": "Object",
            "description": "The return value of the block"
          },
          "example": "# Nested cameras\n  world_camera.use do\r\n    draw_world()\r\n  end\r\n  # UI drawn outside camera (screen space)\r\n  draw_ui()\r"
        },
        "begin": {
          "description": "Begin camera transform. All subsequent sprite draws will use this camera until `end` is called. Prefer `use { }` block syntax when possible.",
          "returns": {
            "type": "Camera2D",
            "description": "self for chaining"
          },
          "example": "camera.begin"
        },
        "end": {
          "description": "End camera transform. Should be called after `begin`.",
          "returns": {
            "type": "Camera2D",
            "description": "self for chaining"
          }
        },
        "current=": {
          "description": "Set the current active camera (class method). This camera will be used for sprite rendering and coordinate transformations.",
          "params": [
            {
              "name": "value",
              "type": "Camera2D, nil",
              "description": "The camera to make current, or nil to clear"
            }
          ],
          "returns": {
            "type": "Camera2D, nil",
            "description": "The value that was set"
          },
          "example": "Camera2D.current = nil  # No camera"
        },
        "current": {
          "description": "Get the current active camera (class method). Returns nil if no camera is set.",
          "returns": {
            "type": "Camera2D, nil",
            "description": "The current camera, or nil"
          },
          "example": "cam = Camera2D.current"
        }
      }
    },
    "GMR::CollisionResult": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "x": {
          "description": "Get the resolved X position after collision.",
          "returns": {
            "type": "Float",
            "description": "Resolved X position"
          }
        },
        "y": {
          "description": "Get the resolved Y position after collision.",
          "returns": {
            "type": "Float",
            "description": "Resolved Y position"
          }
        },
        "vx": {
          "description": "Get the resolved X velocity after collision (zeroed if hit wall).",
          "returns": {
            "type": "Float",
            "description": "Resolved X velocity"
          }
        },
        "vy": {
          "description": "Get the resolved Y velocity after collision (zeroed if hit floor/ceiling).",
          "returns": {
            "type": "Float",
            "description": "Resolved Y velocity"
          }
        },
        "left?": {
          "description": "Check if collided with a wall on the left.",
          "returns": {
            "type": "Boolean",
            "description": "true if hit left wall"
          }
        },
        "right?": {
          "description": "Check if collided with a wall on the right.",
          "returns": {
            "type": "Boolean",
            "description": "true if hit right wall"
          }
        },
        "top?": {
          "description": "Check if collided with a ceiling.",
          "returns": {
            "type": "Boolean",
            "description": "true if hit ceiling"
          }
        },
        "bottom?": {
          "description": "Check if collided with the ground (landed).",
          "returns": {
            "type": "Boolean",
            "description": "true if hit ground"
          }
        },
        "grounded?": {
          "description": "Alias for bottom? - Check if on the ground.",
          "returns": {
            "type": "Boolean",
            "description": "true if on ground"
          }
        },
        "hit_horizontal?": {
          "description": "Check if collided horizontally (left or right wall).",
          "returns": {
            "type": "Boolean",
            "description": "true if hit any horizontal surface"
          }
        },
        "hit_vertical?": {
          "description": "Check if collided vertically (floor or ceiling).",
          "returns": {
            "type": "Boolean",
            "description": "true if hit any vertical surface"
          }
        },
        "any?": {
          "description": "Geometry collision detection utilities. Provides fast tests for point, rectangle, and circle collisions, as well as tile-based collision helpers.",
          "returns": {
            "type": "Boolean",
            "description": "true if any collision happened"
          },
          "example": "# Mouse hover detection for UI buttons\n  class Button\r\n    def update(dt)\r\n      mx = GMR::Input.mouse_x\r\n      my = GMR::Input.mouse_y\r"
        }
      }
    },
    "GMR::Ease": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "linear": {
          "description": "Linear interpolation (no easing). Constant speed throughout.",
          "returns": {
            "type": "Symbol",
            "description": ":linear"
          }
        },
        "in_quad": {
          "description": "Quadratic ease-in. Starts slow, accelerates.",
          "returns": {
            "type": "Symbol",
            "description": ":in_quad"
          }
        },
        "out_quad": {
          "description": "Quadratic ease-out. Starts fast, decelerates.",
          "returns": {
            "type": "Symbol",
            "description": ":out_quad"
          }
        },
        "in_out_quad": {
          "description": "Quadratic ease-in-out. Slow start and end, fast middle.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_quad"
          }
        },
        "in_cubic": {
          "description": "Cubic ease-in. Starts slow, accelerates more than quadratic.",
          "returns": {
            "type": "Symbol",
            "description": ":in_cubic"
          }
        },
        "out_cubic": {
          "description": "Cubic ease-out. Starts fast, decelerates smoothly. Most common.",
          "returns": {
            "type": "Symbol",
            "description": ":out_cubic"
          }
        },
        "in_out_cubic": {
          "description": "Cubic ease-in-out. Smooth acceleration and deceleration.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_cubic"
          }
        },
        "in_quart": {
          "description": "Quartic ease-in. Dramatic slow start.",
          "returns": {
            "type": "Symbol",
            "description": ":in_quart"
          }
        },
        "out_quart": {
          "description": "Quartic ease-out. Dramatic fast start.",
          "returns": {
            "type": "Symbol",
            "description": ":out_quart"
          }
        },
        "in_out_quart": {
          "description": "Quartic ease-in-out.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_quart"
          }
        },
        "in_sine": {
          "description": "Sinusoidal ease-in. Gentle acceleration.",
          "returns": {
            "type": "Symbol",
            "description": ":in_sine"
          }
        },
        "out_sine": {
          "description": "Sinusoidal ease-out. Gentle deceleration.",
          "returns": {
            "type": "Symbol",
            "description": ":out_sine"
          }
        },
        "in_out_sine": {
          "description": "Sinusoidal ease-in-out. Very smooth, subtle effect.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_sine"
          }
        },
        "in_expo": {
          "description": "Exponential ease-in. Extreme slow start.",
          "returns": {
            "type": "Symbol",
            "description": ":in_expo"
          }
        },
        "out_expo": {
          "description": "Exponential ease-out. Extreme fast start.",
          "returns": {
            "type": "Symbol",
            "description": ":out_expo"
          }
        },
        "in_out_expo": {
          "description": "Exponential ease-in-out.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_expo"
          }
        },
        "in_circ": {
          "description": "Circular ease-in.",
          "returns": {
            "type": "Symbol",
            "description": ":in_circ"
          }
        },
        "out_circ": {
          "description": "Circular ease-out.",
          "returns": {
            "type": "Symbol",
            "description": ":out_circ"
          }
        },
        "in_out_circ": {
          "description": "Circular ease-in-out.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_circ"
          }
        },
        "in_back": {
          "description": "Back ease-in. Pulls back before moving forward.",
          "returns": {
            "type": "Symbol",
            "description": ":in_back"
          }
        },
        "out_back": {
          "description": "Back ease-out. Overshoots target, then settles. Great for UI.",
          "returns": {
            "type": "Symbol",
            "description": ":out_back"
          }
        },
        "in_out_back": {
          "description": "Back ease-in-out. Overshoots on both ends.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_back"
          }
        },
        "in_elastic": {
          "description": "Elastic ease-in. Spring-like wind-up.",
          "returns": {
            "type": "Symbol",
            "description": ":in_elastic"
          }
        },
        "out_elastic": {
          "description": "Elastic ease-out. Spring-like bounce at end. Great for attention.",
          "returns": {
            "type": "Symbol",
            "description": ":out_elastic"
          }
        },
        "in_out_elastic": {
          "description": "Elastic ease-in-out. Spring on both ends.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_elastic"
          }
        },
        "in_bounce": {
          "description": "Bounce ease-in. Bouncing at start.",
          "returns": {
            "type": "Symbol",
            "description": ":in_bounce"
          }
        },
        "out_bounce": {
          "description": "Bounce ease-out. Bouncing at end, like a ball.",
          "returns": {
            "type": "Symbol",
            "description": ":out_bounce"
          }
        },
        "in_out_bounce": {
          "description": "Bounce ease-in-out. Bouncing on both ends.",
          "returns": {
            "type": "Symbol",
            "description": ":in_out_bounce"
          }
        },
        "apply": {
          "description": "Apply an easing function to a normalized time value. Useful for custom interpolation outside of tweens.",
          "params": [
            {
              "name": "ease",
              "type": "Symbol",
              "description": "The easing function to apply"
            },
            {
              "name": "t",
              "type": "Float",
              "description": "Normalized time (0.0 to 1.0)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Eased value (usually 0.0 to 1.0, but may overshoot for elastic/back)"
          },
          "example": "# Custom interpolation\n  t = elapsed / duration\r\n  eased_t = GMR::Ease.apply(:out_back, t)\r\n  current_x = start_x + (end_x - start_x) * eased_t\r"
        }
      }
    },
    "GMR::Graphics::Texture": {
      "kind": "class",
      "description": "TODO: Add description",
      "classMethods": {
        "load": {
          "description": "Load a texture from a file. Supports PNG, JPG, BMP, and other common formats.",
          "params": [
            {
              "name": "path",
              "type": "String",
              "description": "Path to the image file (relative to game root)"
            }
          ],
          "returns": {
            "type": "Texture",
            "description": "The loaded texture object"
          },
          "raises": [
            "RuntimeError if the file cannot be loaded"
          ],
          "example": "sprite = GMR::Graphics::Texture.load(\"assets/player.png\")"
        }
      },
      "instanceMethods": {
        "width": {
          "description": "Get the texture width in pixels",
          "returns": {
            "type": "Integer",
            "description": "Width in pixels"
          },
          "example": "puts sprite.width"
        },
        "height": {
          "description": "Get the texture height in pixels",
          "returns": {
            "type": "Integer",
            "description": "Height in pixels"
          },
          "example": "puts sprite.height"
        },
        "release": {
          "description": "Manually release a reference to the texture. When the reference count reaches 0, the texture is unloaded from memory.",
          "returns": {
            "type": "nil"
          },
          "example": "texture.release  # Release this reference"
        },
        "ref_count": {
          "description": "Get the current reference count for this texture (how many times it's been loaded)",
          "returns": {
            "type": "Integer",
            "description": "Current reference count"
          },
          "example": "puts texture.ref_count  # -> 3 (texture is loaded in 3 places)"
        },
        "draw": {
          "description": "Draw the texture at a position, optionally with a color tint",
          "params": [
            {
              "name": "x",
              "type": "Integer",
              "description": "X position (left edge)"
            },
            {
              "name": "y",
              "type": "Integer",
              "description": "Y position (top edge)"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "(optional, default: [255, 255, 255]) Color tint (multiplied with texture)"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "sprite.draw(100, 100)"
        },
        "draw_ex": {
          "description": "Draw the texture with rotation and scaling",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "X position"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "Y position"
            },
            {
              "name": "rotation",
              "type": "Float",
              "description": "Rotation angle in degrees"
            },
            {
              "name": "scale",
              "type": "Float",
              "description": "Scale multiplier (1.0 = original size)"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "(optional, default: [255, 255, 255]) Color tint"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "sprite.draw_ex(160, 120, 45.0, 2.0)"
        },
        "draw_pro": {
          "description": "A tile-based map for efficient rendering of large worlds using a tileset texture",
          "params": [
            {
              "name": "sx",
              "type": "Float",
              "description": "Source X (top-left of region)"
            },
            {
              "name": "sy",
              "type": "Float",
              "description": "Source Y (top-left of region)"
            },
            {
              "name": "sw",
              "type": "Float",
              "description": "Source width"
            },
            {
              "name": "sh",
              "type": "Float",
              "description": "Source height"
            },
            {
              "name": "dx",
              "type": "Float",
              "description": "Destination X (center)"
            },
            {
              "name": "dy",
              "type": "Float",
              "description": "Destination Y (center)"
            },
            {
              "name": "dw",
              "type": "Float",
              "description": "Destination width"
            },
            {
              "name": "dh",
              "type": "Float",
              "description": "Destination height"
            },
            {
              "name": "rotation",
              "type": "Float",
              "description": "Rotation angle in degrees"
            },
            {
              "name": "color",
              "type": "Color",
              "description": "(optional, default: [255, 255, 255]) Color tint"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "sprite.draw_pro(0, 0, 32, 32, 160, 120, 64, 64, 0)"
        }
      }
    },
    "GMR::Graphics::Tilemap": {
      "kind": "class",
      "description": "TODO: Add description",
      "classMethods": {
        "new": {
          "signature": "new(tileset:, tile_width:, tile_height:, width:, height:)",
          "description": "Create a new tilemap with the specified dimensions. All tiles are initialized to -1 (empty/transparent).",
          "params": [
            {
              "name": "tileset",
              "type": "Texture",
              "description": "The tileset texture containing all tile graphics"
            },
            {
              "name": "tile_width",
              "type": "Integer",
              "description": "Width of each tile in pixels"
            },
            {
              "name": "tile_height",
              "type": "Integer",
              "description": "Height of each tile in pixels"
            },
            {
              "name": "width",
              "type": "Integer",
              "description": "Map width in tiles"
            },
            {
              "name": "height",
              "type": "Integer",
              "description": "Map height in tiles"
            }
          ],
          "returns": {
            "type": "Tilemap",
            "description": "The new tilemap object"
          },
          "raises": [
            "ArgumentError if dimensions are not positive"
          ],
          "example": "tileset = GMR::Graphics::Texture.load(\"assets/tiles.png\")\nmap = GMR::Graphics::Tilemap.new(tileset, 16, 16, 100, 50)\r"
        }
      },
      "instanceMethods": {
        "tile_width": {
          "signature": "tile_width",
          "description": "TODO: Add documentation",
          "params": [],
          "returns": {
            "type": "unknown"
          }
        },
        "tile_height": {
          "signature": "tile_height",
          "description": "TODO: Add documentation",
          "params": [],
          "returns": {
            "type": "unknown"
          }
        },
        "fill": {
          "signature": "fill(arg1)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "fill_rect": {
          "signature": "fill_rect(arg1, arg2, arg3, arg4, arg5)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            },
            {
              "name": "arg3",
              "type": "Integer"
            },
            {
              "name": "arg4",
              "type": "Integer"
            },
            {
              "name": "arg5",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "draw_region": {
          "signature": "draw_region(arg1, arg2, arg3, arg4, arg5, arg6, [arg7])",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Float"
            },
            {
              "name": "arg2",
              "type": "Float"
            },
            {
              "name": "arg3",
              "type": "Integer"
            },
            {
              "name": "arg4",
              "type": "Integer"
            },
            {
              "name": "arg5",
              "type": "Integer"
            },
            {
              "name": "arg6",
              "type": "Integer"
            },
            {
              "name": "arg7",
              "type": "Array",
              "optional": true
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "define_tile": {
          "signature": "define_tile(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Hash"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "tile_properties": {
          "signature": "tile_properties(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "tile_property": {
          "signature": "tile_property(arg1, arg2, arg3)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            },
            {
              "name": "arg3",
              "type": "Symbol"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "solid?": {
          "signature": "solid?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "wall?": {
          "signature": "wall?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "any"
            },
            {
              "name": "arg2",
              "type": "any"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "hazard?": {
          "signature": "hazard?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "platform?": {
          "signature": "platform?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "ladder?": {
          "signature": "ladder?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "water?": {
          "signature": "water?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "slippery?": {
          "signature": "slippery?(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        },
        "damage": {
          "signature": "damage(arg1, arg2)",
          "description": "TODO: Add documentation",
          "params": [
            {
              "name": "arg1",
              "type": "Integer"
            },
            {
              "name": "arg2",
              "type": "Integer"
            }
          ],
          "returns": {
            "type": "unknown"
          }
        }
      }
    },
    "Vec2": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Vec2 with optional x and y values.",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "The x component (default: 0)"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "The y component (default: 0)"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The new vector"
          },
          "example": "Vec2.new(100, 200)    # (100, 200)"
        },
        "x": {
          "description": "Get the x component.",
          "returns": {
            "type": "Float",
            "description": "The x value"
          },
          "example": "x = vec.x"
        },
        "y": {
          "description": "Get the y component.",
          "returns": {
            "type": "Float",
            "description": "The y value"
          },
          "example": "y = vec.y"
        },
        "+": {
          "description": "Add two vectors, returning a new Vec2.",
          "params": [
            {
              "name": "other",
              "type": "Vec2",
              "description": "The vector to add"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "A new vector with the sum"
          },
          "example": "result = Vec2.new(1, 2) + Vec2.new(3, 4)  # Vec2(4, 6)"
        },
        "-": {
          "description": "Subtract two vectors, returning a new Vec2.",
          "params": [
            {
              "name": "other",
              "type": "Vec2",
              "description": "The vector to subtract"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "A new vector with the difference"
          },
          "example": "result = Vec2.new(5, 5) - Vec2.new(2, 1)  # Vec2(3, 4)"
        },
        "*": {
          "description": "Multiply vector by a scalar, returning a new Vec2.",
          "params": [
            {
              "name": "scalar",
              "type": "Float",
              "description": "The scalar value"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "A new scaled vector"
          },
          "example": "result = Vec2.new(2, 3) * 2.0  # Vec2(4, 6)"
        },
        "/": {
          "description": "Divide vector by a scalar, returning a new Vec2.",
          "params": [
            {
              "name": "scalar",
              "type": "Float",
              "description": "The scalar value (must not be zero)"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "A new scaled vector"
          },
          "example": "result = Vec2.new(10, 20) / 2.0  # Vec2(5, 10)"
        },
        "to_s": {
          "description": "Convert to a string representation.",
          "returns": {
            "type": "String",
            "description": "String in format \"Vec2(x, y)\""
          },
          "example": "puts Vec2.new(1, 2).to_s  # \"Vec2(1.00, 2.00)\""
        },
        "to_a": {
          "description": "A 3D vector with x, y, and z components. Used for 3D positions, colors (RGB), and other 3-component values. Supports arithmetic operations.",
          "returns": {
            "type": "Array<Float>",
            "description": "Array containing [x, y]"
          },
          "example": "# 3D position for parallax layers\n  class ParallaxLayer\r\n    def initialize(texture, depth)\r"
        }
      }
    },
    "Vec3": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Vec3 with optional x, y, and z values.",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "The x component (default: 0)"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "The y component (default: 0)"
            },
            {
              "name": "z",
              "type": "Float",
              "description": "The z component (default: 0)"
            }
          ],
          "returns": {
            "type": "Vec3",
            "description": "The new vector"
          },
          "example": "Vec3.new(1, 2, 3)     # (1, 2, 3)"
        },
        "x": {
          "description": "Get the x component.",
          "returns": {
            "type": "Float",
            "description": "The x value"
          },
          "example": "x = vec.x"
        },
        "y": {
          "description": "Get the y component.",
          "returns": {
            "type": "Float",
            "description": "The y value"
          },
          "example": "y = vec.y"
        },
        "z": {
          "description": "Get the z component.",
          "returns": {
            "type": "Float",
            "description": "The z value"
          },
          "example": "z = vec.z"
        },
        "+": {
          "description": "Add two vectors, returning a new Vec3.",
          "params": [
            {
              "name": "other",
              "type": "Vec3",
              "description": "The vector to add"
            }
          ],
          "returns": {
            "type": "Vec3",
            "description": "A new vector with the sum"
          },
          "example": "result = Vec3.new(1, 2, 3) + Vec3.new(1, 1, 1)  # Vec3(2, 3, 4)"
        },
        "-": {
          "description": "Subtract two vectors, returning a new Vec3.",
          "params": [
            {
              "name": "other",
              "type": "Vec3",
              "description": "The vector to subtract"
            }
          ],
          "returns": {
            "type": "Vec3",
            "description": "A new vector with the difference"
          },
          "example": "result = Vec3.new(5, 5, 5) - Vec3.new(1, 2, 3)  # Vec3(4, 3, 2)"
        },
        "*": {
          "description": "Multiply vector by a scalar, returning a new Vec3.",
          "params": [
            {
              "name": "scalar",
              "type": "Float",
              "description": "The scalar value"
            }
          ],
          "returns": {
            "type": "Vec3",
            "description": "A new scaled vector"
          },
          "example": "result = Vec3.new(1, 2, 3) * 2.0  # Vec3(2, 4, 6)"
        },
        "/": {
          "description": "Divide vector by a scalar, returning a new Vec3.",
          "params": [
            {
              "name": "scalar",
              "type": "Float",
              "description": "The scalar value (must not be zero)"
            }
          ],
          "returns": {
            "type": "Vec3",
            "description": "A new scaled vector"
          },
          "example": "result = Vec3.new(10, 20, 30) / 10.0  # Vec3(1, 2, 3)"
        },
        "to_s": {
          "description": "A rectangle with position (x, y) and dimensions (w, h). Used for bounds, source rectangles, collision areas, and UI layout.",
          "returns": {
            "type": "String",
            "description": "String in format \"Vec3(x, y, z)\""
          },
          "example": "# UI layout helper\n  class UILayoutHelper\r\n    def initialize(container)\r"
        }
      }
    },
    "Rect": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Rect with optional position and dimensions.",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "The x position (default: 0)"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "The y position (default: 0)"
            },
            {
              "name": "w",
              "type": "Float",
              "description": "The width (default: 0)"
            },
            {
              "name": "h",
              "type": "Float",
              "description": "The height (default: 0)"
            }
          ],
          "returns": {
            "type": "Rect",
            "description": "The new rectangle"
          },
          "example": "Rect.new(10, 20, 100, 50)   # x=10, y=20, w=100, h=50"
        },
        "x": {
          "description": "Get the x position (left edge).",
          "returns": {
            "type": "Float",
            "description": "The x position"
          },
          "example": "x = rect.x"
        },
        "y": {
          "description": "Get the y position (top edge).",
          "returns": {
            "type": "Float",
            "description": "The y position"
          },
          "example": "y = rect.y"
        },
        "w": {
          "description": "Get the width.",
          "returns": {
            "type": "Float",
            "description": "The width"
          },
          "example": "width = rect.w"
        },
        "h": {
          "description": "Get the height.",
          "returns": {
            "type": "Float",
            "description": "The height"
          },
          "example": "height = rect.h"
        },
        "to_s": {
          "description": "Common math utility functions for game development. Provides lerp, clamp, smoothstep, and other interpolation helpers. Named \"Mathf\" to avoid conflict with Ruby's built-in Math module.",
          "returns": {
            "type": "String",
            "description": "String in format \"Rect(x, y, w, h)\""
          },
          "example": "# Smooth transitions\n  t = elapsed / duration\r\n  alpha = Mathf.smoothstep(0, 1, t) * 255\r"
        }
      }
    },
    "GMR::Mathf": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "lerp": {
          "description": "Linear interpolation between two values.",
          "params": [
            {
              "name": "a",
              "type": "Float",
              "description": "Start value"
            },
            {
              "name": "b",
              "type": "Float",
              "description": "End value"
            },
            {
              "name": "t",
              "type": "Float",
              "description": "Interpolation factor (0.0 to 1.0)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Interpolated value"
          },
          "example": "Mathf.lerp(10, 20, 0.25) # => 12.5"
        },
        "clamp": {
          "description": "Clamp a value between minimum and maximum bounds.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The value to clamp"
            },
            {
              "name": "min",
              "type": "Float",
              "description": "Minimum bound"
            },
            {
              "name": "max",
              "type": "Float",
              "description": "Maximum bound"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Clamped value"
          },
          "example": "Mathf.clamp(50, 0, 100)   # => 50.0"
        },
        "smoothstep": {
          "description": "Smooth Hermite interpolation between two values. Produces an S-curve that eases in and out.",
          "params": [
            {
              "name": "edge0",
              "type": "Float",
              "description": "Lower edge"
            },
            {
              "name": "edge1",
              "type": "Float",
              "description": "Upper edge"
            },
            {
              "name": "x",
              "type": "Float",
              "description": "Input value"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Smoothed value (0.0 to 1.0 when x is between edges)"
          },
          "example": "Mathf.smoothstep(0, 1, 0.25) # => ~0.156"
        },
        "inverse_lerp": {
          "description": "Find the interpolation factor for a value between two bounds. The inverse of lerp - given a value, find what t would produce it.",
          "params": [
            {
              "name": "a",
              "type": "Float",
              "description": "Start value"
            },
            {
              "name": "b",
              "type": "Float",
              "description": "End value"
            },
            {
              "name": "value",
              "type": "Float",
              "description": "The value to find the factor for"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Interpolation factor (can be outside 0-1 if value is outside a-b)"
          },
          "example": "Mathf.inverse_lerp(10, 20, 15)  # => 0.5"
        },
        "remap": {
          "description": "Remap a value from one range to another.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "Input value"
            },
            {
              "name": "in_min",
              "type": "Float",
              "description": "Input range minimum"
            },
            {
              "name": "in_max",
              "type": "Float",
              "description": "Input range maximum"
            },
            {
              "name": "out_min",
              "type": "Float",
              "description": "Output range minimum"
            },
            {
              "name": "out_max",
              "type": "Float",
              "description": "Output range maximum"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Remapped value"
          },
          "example": "Mathf.remap(0.5, 0, 1, 0, 255)   # => 127.5"
        },
        "distance": {
          "description": "Calculate Euclidean distance between two 2D points.",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First point X"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First point Y"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second point X"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second point Y"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Distance between points"
          },
          "example": "Mathf.distance(0, 0, 3, 4)  # => 5.0"
        },
        "distance_squared": {
          "description": "Calculate squared distance between two 2D points. Faster than distance() when you only need to compare distances.",
          "params": [
            {
              "name": "x1",
              "type": "Float",
              "description": "First point X"
            },
            {
              "name": "y1",
              "type": "Float",
              "description": "First point Y"
            },
            {
              "name": "x2",
              "type": "Float",
              "description": "Second point X"
            },
            {
              "name": "y2",
              "type": "Float",
              "description": "Second point Y"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Squared distance between points"
          },
          "example": "Mathf.distance_squared(0, 0, 3, 4)  # => 25.0"
        },
        "sign": {
          "description": "Get the sign of a number (-1, 0, or 1).",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The value to check"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "-1 if negative, 0 if zero, 1 if positive"
          },
          "example": "Mathf.sign(10)  # => 1"
        },
        "move_toward": {
          "description": "Move a value toward a target by a maximum delta.",
          "params": [
            {
              "name": "current",
              "type": "Float",
              "description": "Current value"
            },
            {
              "name": "target",
              "type": "Float",
              "description": "Target value"
            },
            {
              "name": "max_delta",
              "type": "Float",
              "description": "Maximum amount to move"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "New value moved toward target"
          },
          "example": "Mathf.move_toward(95, 100, 10)  # => 100.0"
        },
        "wrap": {
          "description": "Wrap a value within a range (like modulo but works with floats and negatives).",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The value to wrap"
            },
            {
              "name": "min",
              "type": "Float",
              "description": "Range minimum"
            },
            {
              "name": "max",
              "type": "Float",
              "description": "Range maximum"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Wrapped value"
          },
          "example": "Mathf.wrap(-10, 0, 360)  # => 350.0"
        },
        "deg_to_rad": {
          "description": "Convert degrees to radians.",
          "params": [
            {
              "name": "degrees",
              "type": "Float",
              "description": "Angle in degrees"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Angle in radians"
          },
          "example": "Mathf.deg_to_rad(180)  # => ~3.14159"
        },
        "rad_to_deg": {
          "description": "Convert radians to degrees.",
          "params": [
            {
              "name": "radians",
              "type": "Float",
              "description": "Angle in radians"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "Angle in degrees"
          },
          "example": "Mathf.rad_to_deg(Math::PI)  # => 180.0"
        },
        "random_int": {
          "description": "Generate a random integer within an inclusive range.",
          "params": [
            {
              "name": "min",
              "type": "Integer",
              "description": "Minimum value (inclusive)"
            },
            {
              "name": "max",
              "type": "Integer",
              "description": "Maximum value (inclusive)"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "Random integer between min and max"
          },
          "example": "spawn_x = Mathf.random_int(0, 800)"
        },
        "random_float": {
          "description": "Generate a random float between 0.0 and 1.0.",
          "returns": {
            "type": "Float",
            "description": "Random float in range [0.0, 1.0]"
          },
          "example": "# Random value in custom range\n  speed = 50 + Mathf.random_float * 100  # 50-150\r"
        }
      }
    },
    "Node": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Node with default transform.",
          "returns": {
            "type": "Node",
            "description": "The new node"
          },
          "example": "node = Node.new"
        },
        "add_child": {
          "description": "Add a child node. Removes from previous parent if any. Cycle detection prevents a node from becoming its own ancestor.",
          "params": [
            {
              "name": "child",
              "type": "Node",
              "description": "The node to add as a child"
            }
          ],
          "returns": {
            "type": "Node",
            "description": "self for chaining"
          },
          "example": "root.add_child(child)"
        },
        "remove_child": {
          "description": "Remove a child node. The child becomes a root node.",
          "params": [
            {
              "name": "child",
              "type": "Node",
              "description": "The node to remove"
            }
          ],
          "returns": {
            "type": "Node",
            "description": "self for chaining"
          },
          "example": "root.remove_child(child)"
        },
        "parent": {
          "description": "Get the parent node, or nil if this is a root.",
          "returns": {
            "type": "Node, nil",
            "description": "The parent node"
          },
          "example": "if node.parent then puts \"has parent\" end"
        },
        "children": {
          "description": "Get an array of child nodes.",
          "returns": {
            "type": "Array<Node>",
            "description": "Array of children (empty if none)"
          },
          "example": "node.children.each { |c| puts c.local_position }"
        },
        "child_count": {
          "description": "Get the number of children.",
          "returns": {
            "type": "Integer",
            "description": "Number of children"
          },
          "example": "puts node.child_count"
        },
        "local_position": {
          "description": "Get the local position relative to parent.",
          "returns": {
            "type": "Vec2",
            "description": "The local position"
          },
          "example": "pos = node.local_position"
        },
        "local_rotation": {
          "description": "Get the local rotation in degrees.",
          "returns": {
            "type": "Float",
            "description": "The local rotation"
          },
          "example": "angle = node.local_rotation"
        },
        "local_scale": {
          "description": "Get the local scale.",
          "returns": {
            "type": "Vec2",
            "description": "The local scale"
          },
          "example": "scale = node.local_scale"
        },
        "local_position=": {
          "description": "Set the local position relative to parent.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The new local position"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "node.local_position = Vec2.new(100, 50)"
        },
        "local_rotation=": {
          "description": "Set the local rotation in degrees.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new local rotation"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "node.local_rotation = 45"
        },
        "local_scale=": {
          "description": "Set the local scale.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The new local scale"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "node.local_scale = Vec2.new(2, 2)"
        },
        "world_position": {
          "description": "Get the world position after hierarchy composition. Call Node.update_world_transforms(root) first to ensure accuracy.",
          "returns": {
            "type": "Vec2",
            "description": "The world position"
          },
          "example": "pos = child.world_position"
        },
        "world_rotation": {
          "description": "Get the world rotation in degrees after hierarchy composition.",
          "returns": {
            "type": "Float",
            "description": "The world rotation"
          },
          "example": "angle = child.world_rotation"
        },
        "world_scale": {
          "description": "Get the world scale after hierarchy composition.",
          "returns": {
            "type": "Vec2",
            "description": "The world scale"
          },
          "example": "scale = child.world_scale"
        },
        "active": {
          "description": "Get the active flag of this node (ignores parent state).",
          "returns": {
            "type": "Boolean",
            "description": "true if this node is active"
          },
          "example": "if node.active then ... end"
        },
        "active=": {
          "description": "Set the active flag of this node.",
          "params": [
            {
              "name": "value",
              "type": "Boolean",
              "description": "true to activate, false to deactivate"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "The value that was set"
          },
          "example": "node.active = false"
        },
        "active?": {
          "description": "Check if this node is active in the full hierarchy. Returns false if this node or any ancestor is inactive.",
          "returns": {
            "type": "Boolean",
            "description": "true if active in hierarchy"
          },
          "example": "if node.active? then update(node) end"
        },
        "Node.update_world_transforms": {
          "description": "Update world transforms for a node and all descendants. Call this on the root before reading world_position/rotation/scale.",
          "params": [
            {
              "name": "root",
              "type": "Node",
              "description": "The root node to start from"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "Node.update_world_transforms(root)"
        }
      }
    },
    "GMR::Scene": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "init": {
          "description": "Called once when the scene becomes active. Override to initialize scene state."
        },
        "update": {
          "description": "Called every frame while this scene is on top of the stack. Override to update game logic.",
          "params": [
            {
              "name": "dt",
              "type": "Float",
              "description": "Delta time in seconds since last frame"
            }
          ]
        },
        "draw": {
          "description": "Called every frame while this scene is on top of the stack. Override to draw scene content."
        },
        "unload": {
          "description": "Stack-based scene lifecycle manager. Use load to switch scenes (clears stack), push to add a scene on top, and pop to return to the previous scene."
        }
      }
    },
    "GMR::SceneManager": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "load": {
          "description": "Clear the scene stack and load a new scene. Calls unload on all existing scenes (top to bottom), then init on the new scene.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The scene to load"
            }
          ],
          "example": "GMR::SceneManager.load(TitleScene.new)"
        },
        "register": {
          "description": "Alias for load. Clear the scene stack and load a new scene.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The scene to load"
            }
          ],
          "example": "GMR::SceneManager.register(TitleScene.new)"
        },
        "push": {
          "description": "Push a new scene onto the stack. The current scene is paused (no longer receives update/draw). Calls init on the new scene.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The scene to push"
            }
          ],
          "example": "GMR::SceneManager.push(PauseScene.new)"
        },
        "pop": {
          "description": "Remove the top scene from the stack. Calls unload on the removed scene. The previous scene resumes receiving update/draw calls.",
          "example": "GMR::SceneManager.pop"
        },
        "update": {
          "description": "Call update on the top scene. Call this from your game's update function.",
          "params": [
            {
              "name": "dt",
              "type": "Float",
              "description": "Delta time in seconds"
            }
          ],
          "example": "def update(dt)\n  GMR::SceneManager.update(dt)\r\nend\r"
        },
        "draw": {
          "description": "Call draw on the top scene. Call this from your game's draw function.",
          "example": "def draw\n  GMR::SceneManager.draw\r\nend\r"
        },
        "add_overlay": {
          "description": "Add an overlay scene that renders on top of the main scene. Overlays receive update and draw calls. Multiple overlays can be active.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The overlay scene to add"
            }
          ],
          "example": "GMR::SceneManager.add_overlay(MinimapOverlay.new)"
        },
        "remove_overlay": {
          "description": "Remove an overlay scene.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The overlay scene to remove"
            }
          ],
          "example": "GMR::SceneManager.remove_overlay(@minimap)"
        },
        "has_overlay?": {
          "description": "Check if an overlay is currently active.",
          "params": [
            {
              "name": "scene",
              "type": "GMR::Scene",
              "description": "The overlay scene to check"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if the overlay is active"
          },
          "example": "if GMR::SceneManager.has_overlay?(@minimap)"
        }
      }
    },
    "Sprite": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new sprite with a texture and transform.",
          "params": [
            {
              "name": "texture",
              "type": "Texture",
              "description": "The texture to render"
            },
            {
              "name": "transform",
              "type": "Transform2D",
              "description": "The transform defining position, rotation, scale, and origin"
            }
          ],
          "returns": {
            "type": "Sprite",
            "description": "The new sprite"
          },
          "example": "\n  transform = Transform2D.new(x: 100, y: 100, rotation: 45)\r\n  sprite = Sprite.new(my_texture, transform)\r"
        },
        "transform": {
          "description": "Get the Transform2D handle associated with this sprite.",
          "returns": {
            "type": "Transform2D",
            "description": "The sprite's transform"
          },
          "example": "t = sprite.transform\n  t.x = 100\r"
        },
        "transform=": {
          "description": "Set the Transform2D for this sprite.",
          "params": [
            {
              "name": "value",
              "type": "Transform2D",
              "description": "The transform to use"
            }
          ],
          "returns": {
            "type": "Transform2D",
            "description": "The value that was set"
          },
          "example": "sprite.transform = Transform2D.new(x: 100, y: 200)"
        },
        "center_origin": {
          "description": "Set the transform's origin to the center of the sprite, so it rotates and scales around its center. Uses texture dimensions or source_rect if set.",
          "returns": {
            "type": "Sprite",
            "description": "self for chaining"
          },
          "example": "sprite = Sprite.new(tex, transform).center_origin  # Method chaining"
        },
        "layer": {
          "description": "Get the render layer. Layers control broad draw order categories. Lower values render first (background), higher values render last (foreground/UI). Returns a symbol for known layer values, or an integer for custom layers.",
          "returns": {
            "type": "Symbol, Integer",
            "description": "The layer as a symbol (:background, :world, :entities, :effects, :ui, :debug) or integer"
          },
          "example": "sprite.layer           # => :entities (default)"
        },
        "layer=": {
          "description": "Set the render layer. Layers organize rendering into broad categories. Sprites in lower layers render first (appear behind), higher layers render last (appear in front). Within a layer, use z for fine-grained depth control.",
          "params": [
            {
              "name": "value",
              "type": "Symbol, Integer",
              "description": "Layer as symbol (:background, :world, :entities, :effects, :ui, :debug) or integer (0-255)"
            }
          ],
          "returns": {
            "type": "Symbol, Integer",
            "description": "The value that was set"
          },
          "example": "# Layer organization"
        },
        "z": {
          "description": "Get the explicit z-index for layering. Returns nil if using automatic draw order (the default). Higher z values render on top of lower values.",
          "returns": {
            "type": "Float, nil",
            "description": "The z-index, or nil if using draw order"
          },
          "example": "if sprite.z.nil?\n  puts \"Using automatic draw order\"\r\nend\r"
        },
        "z=": {
          "description": "Set an explicit z-index for layering, or nil to use draw order. By default (nil), sprites are layered by draw order - later drawn sprites appear on top. Setting an explicit z gives you precise control over layering.",
          "params": [
            {
              "name": "value",
              "type": "Float, nil",
              "description": "The z-index (higher = on top), or nil for draw order"
            }
          ],
          "returns": {
            "type": "Float, nil",
            "description": "The value that was set"
          },
          "example": "# Typical usage pattern"
        },
        "color": {
          "description": "Get the color tint as an RGBA array. White [255,255,255,255] means no tint.",
          "returns": {
            "type": "Array<Integer>",
            "description": "RGBA color array [r, g, b, a]"
          },
          "example": "r, g, b, a = sprite.color"
        },
        "color=": {
          "description": "Set the color tint as an RGBA array. The sprite is multiplied by this color.",
          "params": [
            {
              "name": "value",
              "type": "Array<Integer>",
              "description": "RGBA color array [r, g, b] or [r, g, b, a]"
            }
          ],
          "returns": {
            "type": "Array<Integer>",
            "description": "The value that was set"
          },
          "example": "sprite.color = [255, 255, 255, 128]  # 50% transparent"
        },
        "alpha": {
          "description": "Get the alpha (opacity) as a float from 0.0 (invisible) to 1.0 (opaque).",
          "returns": {
            "type": "Float",
            "description": "The alpha value"
          },
          "example": "a = sprite.alpha"
        },
        "alpha=": {
          "description": "Set the alpha (opacity) from 0.0 (invisible) to 1.0 (opaque).",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new alpha value (0.0 to 1.0)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "sprite.alpha = 0    # Invisible"
        },
        "flip_x": {
          "description": "Check if the sprite is flipped horizontally.",
          "returns": {
            "type": "Boolean",
            "description": "true if flipped horizontally"
          },
          "example": "if sprite.flip_x\n  puts \"Facing left\"\r\nend\r"
        },
        "flip_y": {
          "description": "Check if the sprite is flipped vertically.",
          "returns": {
            "type": "Boolean",
            "description": "true if flipped vertically"
          },
          "example": "if sprite.flip_y\n  puts \"Flipped upside down\"\r\nend\r"
        },
        "flip_x=": {
          "description": "Set whether the sprite is flipped horizontally. Useful for facing direction.",
          "params": [
            {
              "name": "value",
              "type": "Boolean",
              "description": "true to flip horizontally"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "The value that was set"
          },
          "example": "sprite.flip_x = velocity.x < 0  # Face movement direction"
        },
        "flip_y=": {
          "description": "Set whether the sprite is flipped vertically.",
          "params": [
            {
              "name": "value",
              "type": "Boolean",
              "description": "true to flip vertically"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "The value that was set"
          },
          "example": "sprite.flip_y = true"
        },
        "texture": {
          "description": "Get the current texture.",
          "returns": {
            "type": "Texture",
            "description": "The sprite's texture"
          },
          "example": "tex = sprite.texture"
        },
        "texture=": {
          "description": "Set the texture to draw.",
          "params": [
            {
              "name": "value",
              "type": "Texture",
              "description": "The new texture"
            }
          ],
          "returns": {
            "type": "Texture",
            "description": "The value that was set"
          },
          "example": "sprite.texture = new_texture"
        },
        "source_rect": {
          "description": "Get the source rectangle (region of texture to draw). Returns nil if using the entire texture.",
          "returns": {
            "type": "Rect, nil",
            "description": "The source rectangle, or nil if using full texture"
          },
          "example": "rect = sprite.source_rect"
        },
        "source_rect=": {
          "description": "Set the source rectangle to draw only part of the texture. Useful for sprite sheets and animations. Set to nil to draw the full texture.",
          "params": [
            {
              "name": "value",
              "type": "Rect, nil",
              "description": "The source rectangle, or nil for full texture"
            }
          ],
          "returns": {
            "type": "Rect, nil",
            "description": "The value that was set"
          },
          "example": "@sprite.source_rect = nil  # Use full texture"
        },
        "width": {
          "description": "Get the width of the sprite (from source_rect or texture).",
          "returns": {
            "type": "Integer",
            "description": "The width in pixels"
          },
          "example": "w = sprite.width"
        },
        "height": {
          "description": "Get the height of the sprite (from source_rect or texture).",
          "returns": {
            "type": "Integer",
            "description": "The height in pixels"
          },
          "example": "h = sprite.height"
        },
        "draw": {
          "description": "Queue the sprite for rendering. Sprites are drawn in z-order after all draw() calls complete. By default, draw order determines layering (later = on top). Set sprite.z to override with an explicit z-index.",
          "returns": {
            "type": "Sprite",
            "description": "self for chaining"
          },
          "example": "# Method chaining"
        },
        "count": {
          "description": "Get the total number of active sprites (class method).",
          "returns": {
            "type": "Integer",
            "description": "The number of active sprites"
          },
          "example": "puts \"Active sprites: #{Sprite.count}\""
        },
        "play_animation": {
          "description": "Convenience method to create and play a sprite animation. Creates a GMR::SpriteAnimation, calls play, and returns it for chaining.",
          "returns": {
            "type": "SpriteAnimation",
            "description": "The animation instance (already playing)"
          },
          "example": "sprite.play_animation(frames: [0, 1, 2, 3], fps: 12)"
        }
      }
    },
    "GMR::SpriteAnimation": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new sprite animation.",
          "params": [
            {
              "name": "sprite",
              "type": "Sprite",
              "description": "The sprite to animate"
            }
          ],
          "example": "# Attack combo with non-looping animation"
        },
        "play": {
          "description": "Start or resume the animation.",
          "returns": {
            "type": "SpriteAnimation",
            "description": "self for chaining"
          },
          "example": "# State machine integration - play animation when entering run state\n  state :run do\r\n    enter { @animations[:run].play }\r\n    exit { @animations[:run].stop }\r\n    on :stop, :idle\r\n    on :jump, :jumping\r\n  end\r"
        },
        "pause": {
          "description": "Pause the animation at the current frame.",
          "returns": {
            "type": "SpriteAnimation",
            "description": "self for chaining"
          },
          "example": "anim.pause"
        },
        "stop": {
          "description": "Stop the animation and reset to the first frame.",
          "returns": {
            "type": "SpriteAnimation",
            "description": "self for chaining"
          },
          "example": "anim.stop"
        },
        "on_complete": {
          "description": "Set a callback for when the animation finishes (non-looping only).",
          "returns": {
            "type": "SpriteAnimation",
            "description": "self for chaining"
          },
          "example": "# Chain attack animation into recovery state\n  def start_attack\r"
        },
        "on_frame_change": {
          "description": "Set a callback for each frame change. Receives frame index.",
          "returns": {
            "type": "SpriteAnimation",
            "description": "self for chaining"
          },
          "example": "# Spawn attack hitbox on specific frame"
        },
        "playing?": {
          "description": "Check if the animation is currently playing.",
          "returns": {
            "type": "Boolean",
            "description": "true if playing"
          }
        },
        "complete?": {
          "description": "Check if the animation has completed (non-looping only).",
          "returns": {
            "type": "Boolean",
            "description": "true if completed"
          }
        },
        "frame": {
          "description": "Get the current frame index (from the frames array).",
          "returns": {
            "type": "Integer",
            "description": "Current frame index"
          }
        },
        "frame=": {
          "description": "Set the current frame index directly.",
          "params": [
            {
              "name": "index",
              "type": "Integer",
              "description": "Frame index (into frames array)"
            }
          ],
          "returns": {
            "type": "Integer",
            "description": "The frame index"
          }
        },
        "fps": {
          "description": "Get the frames per second.",
          "returns": {
            "type": "Float",
            "description": "FPS"
          }
        },
        "fps=": {
          "description": "Set the frames per second.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "New FPS"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The FPS value"
          },
          "example": "# Speed up animation when player is running fast\n  def update(dt)\r\n    speed = calculate_movement_speed\r\n    # Scale animation FPS with movement speed (8-16 fps range)\r"
        },
        "loop?": {
          "description": "Check if the animation loops.",
          "returns": {
            "type": "Boolean",
            "description": "true if looping"
          }
        },
        "loop=": {
          "description": "Set whether the animation loops.",
          "params": [
            {
              "name": "value",
              "type": "Boolean",
              "description": "true to loop"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "The loop value"
          }
        },
        "count": {
          "description": "Get the number of active sprite animations.",
          "returns": {
            "type": "Integer",
            "description": "Number of active animations"
          }
        }
      }
    },
    "GMR::StateMachine": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "attach": {
          "description": "Attach a state machine to an object. Called internally by Object#state_machine.",
          "params": [
            {
              "name": "owner",
              "type": "Object",
              "description": "The object to attach the state machine to"
            }
          ],
          "returns": {
            "type": "StateMachine",
            "description": "The created state machine"
          }
        },
        "count": {
          "description": "Get the number of active state machines.",
          "returns": {
            "type": "Integer",
            "description": "Number of active machines"
          }
        },
        "trigger": {
          "description": "Trigger an event, causing a transition if one is defined.",
          "params": [
            {
              "name": "event",
              "type": "Symbol",
              "description": "The event to trigger"
            }
          ],
          "returns": {
            "type": "Boolean",
            "description": "true if a transition occurred"
          },
          "example": "# Chain triggers from animation callbacks"
        },
        "state": {
          "description": "Define a state with its behavior.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The state name"
            }
          ]
        },
        "state=": {
          "description": "Force a state change, bypassing transitions.",
          "params": [
            {
              "name": "new_state",
              "type": "Symbol",
              "description": "The state to switch to"
            }
          ],
          "returns": {
            "type": "Symbol",
            "description": "The new state"
          }
        },
        "active?": {
          "description": "Check if the state machine is active.",
          "returns": {
            "type": "Boolean",
            "description": "true if active"
          }
        },
        "animate": {
          "description": "Set the animation to play when entering this state.",
          "params": [
            {
              "name": "name",
              "type": "Symbol",
              "description": "The animation name (looked up in @animations hash)"
            }
          ]
        },
        "on": {
          "description": "Define a transition from this state.",
          "params": [
            {
              "name": "event",
              "type": "Symbol",
              "description": "The event that triggers the transition"
            },
            {
              "name": "target",
              "type": "Symbol",
              "description": "The target state"
            }
          ],
          "example": "# Multiple transitions from same state\n  state :grounded do\r\n    on :jump, :jumping\r\n    on :crouch, :crouching\r\n    on :damage, :hurt\r\n    on :fall, :falling\r\n  end\r"
        },
        "enter": {
          "description": "Set a callback to run when entering this state.",
          "example": "# Initialize state-specific data on enter\n  state :charging do\r\n    enter do\r"
        },
        "exit": {
          "description": "Set a callback to run when exiting this state.",
          "example": "# Cancel pending actions on state exit\n  state :aiming do\r\n    exit do\r"
        },
        "on_input": {
          "description": "Define an input-driven transition from this state.",
          "params": [
            {
              "name": "action",
              "type": "Symbol",
              "description": "The input action that triggers the transition"
            },
            {
              "name": "target",
              "type": "Symbol",
              "description": "The target state"
            }
          ],
          "example": "\n  state :idle do\r\n    on_input :jump, :air\r\n    on_input :attack, :attack, when: :pressed, if: -> { @stamina > 0 }\r\n  end\r\nBuilder#method_missing - Verb-style input transition\r\nUsage: jump :air\r\n       attack.hold :charge\r\n       die! :dead\r\nBuilder#respond_to_missing? - For Ruby introspection\r"
        },
        "state_machine": {
          "description": "Define or get the state machine for this object.",
          "returns": {
            "type": "StateMachine",
            "description": "The state machine"
          }
        }
      }
    },
    "Transform2D": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "initialize": {
          "description": "Create a new Transform2D with optional initial values.",
          "params": [
            {
              "name": "x",
              "type": "Float",
              "description": "Initial X position (default: 0)"
            },
            {
              "name": "y",
              "type": "Float",
              "description": "Initial Y position (default: 0)"
            },
            {
              "name": "rotation",
              "type": "Float",
              "description": "Initial rotation in degrees (default: 0)"
            },
            {
              "name": "scale_x",
              "type": "Float",
              "description": "Initial X scale (default: 1.0)"
            },
            {
              "name": "scale_y",
              "type": "Float",
              "description": "Initial Y scale (default: 1.0)"
            },
            {
              "name": "origin_x",
              "type": "Float",
              "description": "Pivot point X (default: 0)"
            },
            {
              "name": "origin_y",
              "type": "Float",
              "description": "Pivot point Y (default: 0)"
            }
          ],
          "returns": {
            "type": "Transform2D",
            "description": "The new transform"
          },
          "example": "t = Transform2D.new(x: 100, y: 50, rotation: 45)"
        },
        "x": {
          "description": "Get the X position of the transform.",
          "returns": {
            "type": "Float",
            "description": "The X position"
          },
          "example": "x_pos = transform.x"
        },
        "y": {
          "description": "Get the Y position of the transform.",
          "returns": {
            "type": "Float",
            "description": "The Y position"
          },
          "example": "y_pos = transform.y"
        },
        "position": {
          "description": "Get the position as a Vec2.",
          "returns": {
            "type": "Vec2",
            "description": "The position vector"
          },
          "example": "pos = transform.position"
        },
        "rotation": {
          "description": "Get the rotation in degrees.",
          "returns": {
            "type": "Float",
            "description": "The rotation angle in degrees"
          },
          "example": "angle = transform.rotation"
        },
        "scale_x": {
          "description": "Get the X scale factor.",
          "returns": {
            "type": "Float",
            "description": "The X scale (1.0 = normal size)"
          },
          "example": "sx = transform.scale_x"
        },
        "scale_y": {
          "description": "Get the Y scale factor.",
          "returns": {
            "type": "Float",
            "description": "The Y scale (1.0 = normal size)"
          },
          "example": "sy = transform.scale_y"
        },
        "origin_x": {
          "description": "Get the X origin (pivot point) for rotation and scaling.",
          "returns": {
            "type": "Float",
            "description": "The X origin offset in pixels"
          },
          "example": "ox = transform.origin_x"
        },
        "origin_y": {
          "description": "Get the Y origin (pivot point) for rotation and scaling.",
          "returns": {
            "type": "Float",
            "description": "The Y origin offset in pixels"
          },
          "example": "oy = transform.origin_y"
        },
        "x=": {
          "description": "Set the X position of the transform.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new X position"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.x += 5  # Move right by 5 pixels"
        },
        "y=": {
          "description": "Set the Y position of the transform.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new Y position"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.y += 10  # Move down by 10 pixels"
        },
        "position=": {
          "description": "Set the position using a Vec2.",
          "params": [
            {
              "name": "value",
              "type": "Vec2",
              "description": "The new position vector"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The value that was set"
          },
          "example": "transform.position = player.position  # Copy another position"
        },
        "rotation=": {
          "description": "Set the rotation in degrees. Positive values rotate clockwise.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new rotation angle in degrees"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.rotation += 90 * dt  # Rotate 90 degrees per second"
        },
        "scale_x=": {
          "description": "Set the X scale factor. Values greater than 1 stretch horizontally, less than 1 shrink. Negative values flip horizontally.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new X scale (1.0 = normal size)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.scale_x = -1.0  # Flip horizontally"
        },
        "scale_y=": {
          "description": "Set the Y scale factor. Values greater than 1 stretch vertically, less than 1 shrink. Negative values flip vertically.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The new Y scale (1.0 = normal size)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.scale_y = -1.0  # Flip vertically"
        },
        "origin_x=": {
          "description": "Set the X origin (pivot point) for rotation and scaling. The origin is the point around which the transform rotates and scales.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The X origin offset in pixels from top-left"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.origin_x = 16  # Pivot 16px from left edge"
        },
        "origin_y=": {
          "description": "Set the Y origin (pivot point) for rotation and scaling. The origin is the point around which the transform rotates and scales.",
          "params": [
            {
              "name": "value",
              "type": "Float",
              "description": "The Y origin offset in pixels from top-left"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The value that was set"
          },
          "example": "transform.origin_y = 16  # Pivot 16px from top edge"
        },
        "center_origin": {
          "description": "Set the origin to the center of the given dimensions, so the transform rotates and scales around its center point. Useful for sprites, images, or any rectangular object.",
          "params": [
            {
              "name": "w",
              "type": "Float",
              "description": "The width of the object in pixels"
            },
            {
              "name": "h",
              "type": "Float",
              "description": "The height of the object in pixels"
            }
          ],
          "returns": {
            "type": "Transform2D",
            "description": "self for chaining"
          },
          "example": "Transform2D.new(x: 100, y: 100).center_origin(64, 64)  # Method chaining"
        },
        "parent": {
          "description": "Get the parent transform. Returns nil if no parent is set. When a transform has a parent, its position, rotation, and scale are relative to the parent's world transform.",
          "returns": {
            "type": "Transform2D, nil",
            "description": "The parent transform, or nil if none"
          },
          "example": "if transform.parent\n  puts \"Has a parent!\"\r\nend\r"
        },
        "parent=": {
          "description": "Set the parent transform for hierarchical transformations. When parented, this transform's position, rotation, and scale become relative to the parent. Set to nil to remove the parent.",
          "params": [
            {
              "name": "value",
              "type": "Transform2D, nil",
              "description": "The parent transform, or nil to clear"
            }
          ],
          "returns": {
            "type": "Transform2D, nil",
            "description": "The value that was set"
          },
          "example": "transform.parent = nil  # Remove parent"
        },
        "world_position": {
          "description": "Get the final world position after applying all parent transforms. For transforms without a parent, this equals the local position. For parented transforms, this returns the actual screen position after parent transformations.",
          "returns": {
            "type": "Vec2",
            "description": "The world position after parent hierarchy composition"
          },
          "example": "# Get world position of a child transform\n  parent = Transform2D.new(x: 100, y: 100)\r\n  parent.rotation = 90\r\n  child = Transform2D.new(x: 50, y: 0)\r\n  child.parent = parent\r\n  pos = child.world_position  # Position after rotation by parent\r"
        },
        "world_rotation": {
          "description": "Get the final world rotation after applying all parent transforms. For transforms without a parent, this equals the local rotation. For parented transforms, this returns the combined rotation of the entire hierarchy.",
          "returns": {
            "type": "Float",
            "description": "The world rotation in degrees"
          },
          "example": "child_world_rot = transform.world_rotation"
        },
        "world_scale": {
          "description": "Get the final world scale after applying all parent transforms. For transforms without a parent, this equals the local scale. For parented transforms, this returns the combined scale of the entire hierarchy.",
          "returns": {
            "type": "Vec2",
            "description": "The world scale"
          },
          "example": "world_s = transform.world_scale"
        },
        "forward": {
          "description": "Get the forward direction vector after world rotation. The forward vector points in the direction the transform is facing (0 degrees = right).",
          "returns": {
            "type": "Vec2",
            "description": "The normalized forward direction"
          },
          "example": "forward = transform.forward\n  transform.x += forward.x * speed * dt  # Move forward\r"
        },
        "right": {
          "description": "Get the right direction vector after world rotation. The right vector points perpendicular to forward (90 degrees clockwise).",
          "returns": {
            "type": "Vec2",
            "description": "The normalized right direction"
          },
          "example": "right = transform.right\n  transform.x += right.x * strafe_speed * dt  # Strafe right\r"
        },
        "snap_to_grid!": {
          "description": "Snap the position to the nearest grid cell. Useful for tile-based games or ensuring pixel-perfect alignment.",
          "params": [
            {
              "name": "grid_size",
              "type": "Float",
              "description": "The size of each grid cell in pixels"
            }
          ],
          "returns": {
            "type": "nil"
          },
          "example": "transform.snap_to_grid!(16)  # Snap to 16x16 grid"
        },
        "round_to_pixel!": {
          "description": "Round the position to the nearest integer pixel coordinates. Useful for pixel-art games to avoid sub-pixel rendering artifacts.",
          "returns": {
            "type": "nil"
          },
          "example": "transform.round_to_pixel!  # Ensure crisp pixel alignment"
        },
        "Transform2D.lerp_position": {
          "description": "Linearly interpolate between two positions.",
          "params": [
            {
              "name": "a",
              "type": "Vec2",
              "description": "Start position"
            },
            {
              "name": "b",
              "type": "Vec2",
              "description": "End position"
            },
            {
              "name": "t",
              "type": "Float",
              "description": "Interpolation factor (0.0 to 1.0)"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The interpolated position"
          },
          "example": "pos = Transform2D.lerp_position(start_pos, end_pos, 0.5)"
        },
        "Transform2D.lerp_rotation": {
          "description": "Interpolate between two rotation angles using shortest path. Automatically handles wrapping (e.g., 350 to 10 goes through 0, not 340).",
          "params": [
            {
              "name": "a",
              "type": "Float",
              "description": "Start rotation in degrees"
            },
            {
              "name": "b",
              "type": "Float",
              "description": "End rotation in degrees"
            },
            {
              "name": "t",
              "type": "Float",
              "description": "Interpolation factor (0.0 to 1.0)"
            }
          ],
          "returns": {
            "type": "Float",
            "description": "The interpolated rotation in degrees"
          },
          "example": "rot = Transform2D.lerp_rotation(0, 270, 0.5)  # Returns 315 (shortest path)"
        },
        "Transform2D.lerp_scale": {
          "description": "Linearly interpolate between two scale vectors.",
          "params": [
            {
              "name": "a",
              "type": "Vec2",
              "description": "Start scale"
            },
            {
              "name": "b",
              "type": "Vec2",
              "description": "End scale"
            },
            {
              "name": "t",
              "type": "Float",
              "description": "Interpolation factor (0.0 to 1.0)"
            }
          ],
          "returns": {
            "type": "Vec2",
            "description": "The interpolated scale"
          },
          "example": "scale = Transform2D.lerp_scale(Vec2.new(1, 1), Vec2.new(2, 2), 0.5)"
        }
      }
    },
    "GMR::Tween": {
      "kind": "class",
      "description": "TODO: Add description",
      "instanceMethods": {
        "to": {
          "signature": "from(target, property, start_value, duration:, delay:, ease:)",
          "description": "Create a tween that animates a property TO a target value. The tween starts from the property's current value.",
          "params": [
            {
              "name": "target",
              "type": "Object",
              "description": "The object to animate (must have property getter and setter)"
            },
            {
              "name": "property",
              "type": "Symbol",
              "description": "The property to animate (:x, :y, :alpha, :rotation, etc.)"
            },
            {
              "name": "end_value",
              "type": "Float",
              "description": "The target value to animate to"
            }
          ],
          "returns": {
            "type": "Tween",
            "description": "The tween instance for chaining"
          },
          "example": "# Smooth camera zoom for scope/aim mode\n  def toggle_aim_mode\r"
        },
        "from": {
          "description": "Create a tween that animates a property FROM a start value to current. Useful for \"animate in\" effects like fading in from transparent.",
          "params": [
            {
              "name": "target",
              "type": "Object",
              "description": "The object to animate"
            },
            {
              "name": "property",
              "type": "Symbol",
              "description": "The property to animate"
            },
            {
              "name": "start_value",
              "type": "Float",
              "description": "The value to animate from"
            }
          ],
          "returns": {
            "type": "Tween",
            "description": "The tween instance for chaining"
          },
          "example": "# Toast notification slides in from bottom\n  class Toast\r\n    def show(message)\r"
        },
        "on_complete": {
          "description": "Set a callback to invoke when the tween completes.",
          "returns": {
            "type": "Tween",
            "description": "self for chaining"
          },
          "example": "# Sequence of tweens using on_complete for chaining\n  class Chest\r\n    def open\r\n      # First: lid opens\r\n      GMR::Tween.to(@lid, :rotation, -1.5, duration: 0.3, ease: :out_quad)\r\n        .on_complete do\r\n          # Second: spawn item and make it rise\r"
        },
        "on_update": {
          "description": "Set a callback to invoke each frame during the tween. The callback receives (t, value) where t is normalized progress [0-1] and value is the current interpolated value.",
          "returns": {
            "type": "Tween",
            "description": "self for chaining"
          },
          "example": "# Color cycling effect on update\n  def start_rainbow_effect\r"
        },
        "cancel": {
          "description": "Cancel the tween immediately. Does not invoke on_complete.",
          "returns": {
            "type": "nil"
          },
          "example": "# Cancel movement when player hits wall\n  class Player\r\n    def move_to(target_x, target_y)\r"
        },
        "pause": {
          "description": "Pause the tween. Use resume to continue.",
          "returns": {
            "type": "Tween",
            "description": "self for chaining"
          },
          "example": "# Pause all UI animations when game pauses\n  class PauseMenu\r\n    def show\r"
        },
        "resume": {
          "description": "Resume a paused tween.",
          "returns": {
            "type": "Tween",
            "description": "self for chaining"
          },
          "example": "tween.resume"
        },
        "complete?": {
          "description": "Check if the tween has finished.",
          "returns": {
            "type": "Boolean",
            "description": "true if completed"
          },
          "example": "if tween.complete?\n  puts \"Done!\"\r\nend\r"
        },
        "active?": {
          "description": "Check if the tween is currently running (not paused, cancelled, or complete).",
          "returns": {
            "type": "Boolean",
            "description": "true if active"
          },
          "example": "if tween.active?\n  puts \"Still animating...\"\r\nend\r"
        },
        "paused?": {
          "description": "Check if the tween is paused.",
          "returns": {
            "type": "Boolean",
            "description": "true if paused"
          }
        },
        "progress": {
          "description": "Get the current progress of the tween (0.0 to 1.0).",
          "returns": {
            "type": "Float",
            "description": "Progress value"
          }
        },
        "cancel_all": {
          "description": "Cancel all active tweens.",
          "returns": {
            "type": "nil"
          },
          "example": "# Clean slate when transitioning scenes\n  class GameScene < GMR::Scene\r\n    def unload\r\n      # Cancel all tweens to prevent callbacks on destroyed objects\r\n      GMR::Tween.cancel_all\r\n      # Clean up resources\r"
        },
        "count": {
          "description": "Get the number of active tweens.",
          "returns": {
            "type": "Integer",
            "description": "Number of active tweens"
          },
          "example": "puts \"Active tweens: #{GMR::Tween.count}\""
        }
      }
    }
  },
  "globals": {
    "lifecycle": {},
    "helpers": {}
  }
}
